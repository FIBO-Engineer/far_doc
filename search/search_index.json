{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FIBO Engineer ROS Guide","text":""},{"location":"#general","title":"General","text":"<p>Chapter 1: VSCode Setup, SSH Key, GitHub Basics</p> <p>Chapter 2: ROS Overview + Package creation + Dependencies + vcstool</p> <p>Chapter 3: C++ Standard Containers, Standard Pointers and Return Value</p> <p>Chapter 4: C++ Lambda function and extended function usage</p> <p>Chapter 5: C++ Iterator</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/tags/","title":"Hello","text":""},{"location":"blog/tags/#nice-to-meet-you","title":"Nice to meet you","text":"<p>Oh yeah</p>"},{"location":"blog/posts/02_PTT%20copy%202/","title":"HD!","text":"<p>We hope you are all having fun and wish you all the best for the new year!</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</p>"},{"location":"blog/posts/02_PTT%20copy%203/","title":"HD!","text":"<p>We hope you are all having fun and wish you all the best for the new year!</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</p>"},{"location":"blog/posts/02_PTT%20copy%204/","title":"HD!","text":"<p>We hope you are all having fun and wish you all the best for the new year!</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</p>"},{"location":"blog/posts/02_PTT%20copy/","title":"HD!","text":"<p>We hope you are all having fun and wish you all the best for the new year!</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</p>"},{"location":"blog/posts/02_PTT/","title":"HD!","text":"<p>We hope you are all having fun and wish you all the best for the new year!</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</p>"},{"location":"blog/posts/FAR/01_FAR/","title":"Happy new years eve! ve ve ve","text":"<p>We hope you are all having fun and wish you all the best for the new year!</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</p>","tags":["new year","hogmanay","festive season"]},{"location":"cpp/containers/","title":"C++ Containers: A Comprehensive Guide","text":""},{"location":"cpp/containers/#introduction","title":"Introduction","text":"<p>C++ provides a powerful set of container classes within the Standard Template Library (STL). These containers help manage collections of objects efficiently. Containers in C++ are broadly classified into sequence containers, associative containers, and unordered containers.</p>"},{"location":"cpp/containers/#1-sequence-containers","title":"1. Sequence Containers","text":"<p>Sequence containers store elements in a linear fashion. The most commonly used sequence containers are:</p>"},{"location":"cpp/containers/#11-stdvector","title":"1.1 std::vector","text":"<p>A dynamic array that grows as needed. It provides fast random access and efficient insertion/removal at the end. The underlying implementation uses a dynamic array, allowing O(1) access by index but requiring O(n) time for insertions or deletions in the middle.</p> Operation Time Complexity Access (by index) O(1) Insert at end Amortized O(1) Insert at middle O(n) Delete at end O(1) Delete at middle O(n) Get size O(1) <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    std::vector&lt;int&gt; v = {1, 2, 3, 4, 5};\n    v.push_back(6);\n\n    for (int num : v) {\n        std::cout &lt;&lt; num &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> <p>Use Case: - Best for large datasets that require frequent random access and occasional resizing. - Used in graphics processing, dynamic arrays, and buffer storage.</p>"},{"location":"cpp/containers/#12-stdlist","title":"1.2 std::list","text":"<p>A doubly linked list that allows efficient insertion and deletion at any position. It provides O(1) insertions and deletions using iterators but requires O(n) time for index-based access.</p> Operation Time Complexity Access (by index) O(n) Insert at end O(1) Insert at middle O(1) with iterator Delete at end O(1) Delete at middle O(1) with iterator Get size O(1) <pre><code>#include &lt;iostream&gt;\n#include &lt;list&gt;\n\nint main() {\n    std::list&lt;int&gt; lst = {1, 2, 3};\n    lst.push_front(0);\n    lst.push_back(4);\n\n    for (int num : lst) {\n        std::cout &lt;&lt; num &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> <p>Use Case: - Ideal when frequent insertions or deletions in the middle are needed. - Used in task scheduling, undo functionality, and managing ordered elements dynamically.</p>"},{"location":"cpp/containers/#13-stddeque","title":"1.3 std::deque","text":"<p>A double-ended queue that supports fast insertions and deletions at both ends. Unlike <code>vector</code>, <code>deque</code> is implemented as a dynamic array of blocks, ensuring O(1) access but with additional memory overhead.</p> Operation Time Complexity Access (by index) O(1) Insert at end O(1) Insert at middle O(n) Delete at end O(1) Delete at middle O(n) Get size O(1) <pre><code>#include &lt;iostream&gt;\n#include &lt;deque&gt;\n\nint main() {\n    std::deque&lt;int&gt; dq = {2, 3, 4};\n    dq.push_front(1);\n    dq.push_back(5);\n\n    for (int num : dq) {\n        std::cout &lt;&lt; num &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> <p>Use Case: - Useful for double-ended operations where insertions and deletions are needed from both ends. - Common in browser history tracking, task processing, and caching systems.</p>"},{"location":"cpp/containers/#2-associative-containers","title":"2. Associative Containers","text":"<p>Associative containers store elements in a sorted order based on keys.</p>"},{"location":"cpp/containers/#21-stdset","title":"2.1 std::set","text":"<p>A sorted collection of unique elements. Implemented as a Red-Black Tree, allowing efficient O(log n) insertions, deletions, and lookups but no direct indexing.</p> Operation Time Complexity Access (by index) O(n) Insert at end N/A Insert at middle O(log n) Delete at end N/A Delete at middle O(log n) Get size O(1) <pre><code>#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nint main() {\n    std::set&lt;int&gt; s = {4, 2, 5, 1, 3};\n    s.insert(3);\n\n    for (int num : s) {\n        std::cout &lt;&lt; num &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> <p>Use Case: - Useful for maintaining unique elements in sorted order. - Used in leaderboards, unique word counting, and managing sorted records.</p>"},{"location":"cpp/containers/#22-stdmap","title":"2.2 std::map","text":"<p>A key-value pair container sorted by keys. Implemented as a Red-Black Tree, similar to <code>set</code>, providing O(log n) operations for insertions, deletions, and lookups.</p> Operation Time Complexity Access (by index) O(log n) Insert at end N/A Insert at middle O(log n) Delete at end N/A Delete at middle O(log n) Get size O(1) <pre><code>#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nint main() {\n    std::map&lt;int, std::string&gt; m;\n    m[1] = \"one\";\n    m[2] = \"two\";\n    m[3] = \"three\";\n\n    for (const auto&amp; [key, value] : m) {\n        std::cout &lt;&lt; key &lt;&lt; \": \" &lt;&lt; value &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> <p>Use Case: - Best when a sorted dictionary-like structure is needed. - Used in configuration settings, caching mechanisms, and associative data storage.</p>"},{"location":"cpp/containers/#3-unordered-containers","title":"3. Unordered Containers","text":"<p>Unordered containers use hash tables for fast access and do not maintain order.</p>"},{"location":"cpp/containers/#31-stdunordered_set","title":"3.1 std::unordered_set","text":"<p>A collection of unique elements with fast lookup. Implemented as a hash table, allowing O(1) average time complexity for most operations, but worst-case O(n) due to hash collisions.</p> Operation Time Complexity Access (by index) N/A Insert at end N/A Insert at middle O(1) (average), O(n) (worst) Delete at end N/A Delete at middle O(1) (average), O(n) (worst) Get size O(1) <p>Use Case: - Ideal for quick membership testing and duplicate filtering. - Used in hash-based search, spam filtering, and rapid existence checking.</p>"},{"location":"cpp/containers/#32-stdunordered_map","title":"3.2 std::unordered_map","text":"<p>A hash table-based key-value container. Similar to <code>unordered_set</code>, it provides O(1) average-time operations but degrades to O(n) in worst-case scenarios due to hash collisions.</p> Operation Time Complexity Access (by index) O(1) (average), O(n) (worst) Insert at end N/A Insert at middle O(1) (average), O(n) (worst) Delete at end N/A Delete at middle O(1) (average), O(n) (worst) Get size O(1) <pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n\nint main() {\n    std::unordered_map&lt;std::string, int&gt; um;\n    um[\"apple\"] = 3;\n    um[\"banana\"] = 5;\n    um[\"orange\"] = 7;\n\n    for (const auto&amp; [key, value] : um) {\n        std::cout &lt;&lt; key &lt;&lt; \": \" &lt;&lt; value &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> <p>Use Case: - Best for fast key-value lookups without maintaining order. - Used in database indexing, word frequency analysis, and fast data retrieval.</p>"},{"location":"cpp/containers/#understanding-the-backends-of-c-containers","title":"Understanding the Backends of C++ Containers","text":"<p>Each container in the STL is backed by a specific data structure, optimized for different operations:</p> <ul> <li>Dynamic Array (<code>std::vector</code>): Uses a contiguous memory block, allowing fast index access but costly insertions/deletions in the middle.</li> <li>Doubly Linked List (<code>std::list</code>): Uses nodes connected via pointers, allowing O(1) insertions/deletions anywhere but O(n) access by index.</li> <li>Dynamic Array of Blocks (<code>std::deque</code>): A segmented memory model that supports O(1) insertions and deletions at both ends.</li> <li>Red-Black Tree (<code>std::set</code>, <code>std::map</code>): A self-balancing binary search tree that ensures O(log n) operations and maintains elements in sorted order.</li> <li>Hash Table (<code>std::unordered_set</code>, <code>std::unordered_map</code>): Uses hashing for O(1) average-time access, but worst-case performance can degrade to O(n) due to collisions.</li> </ul>"},{"location":"cpp/containers/#features-introduced-in-different-c-versions","title":"Features Introduced in Different C++ Versions","text":"Feature Introduced in std::vector, std::list, std::deque, std::set, std::map C++98 Range-based for loop C++11 std::unordered_map, std::unordered_set C++11 Structured bindings (<code>auto&amp; [key, value]</code>) C++17"},{"location":"cpp/containers/#benchmark","title":"Benchmark","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;list&gt;\n#include &lt;set&gt;\n#include &lt;unordered_set&gt;\n#include &lt;chrono&gt;\n#include &lt;random&gt;\n\nconst int ELEMENTS = 100000;\n\nvoid benchmark_vector() {\n    std::vector&lt;int&gt; vec;\n\n    auto start = std::chrono::high_resolution_clock::now();\n    for (int i = 0; i &lt; ELEMENTS; ++i) {\n        vec.push_back(i);\n    }\n    auto end = std::chrono::high_resolution_clock::now();\n    std::cout &lt;&lt; \"Vector push_back time: \"\n              &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start).count()\n              &lt;&lt; \" \u00b5s\\n\";\n\n    start = std::chrono::high_resolution_clock::now();\n    for (const auto&amp; val : vec) {\n        volatile int x = val;\n    }\n    end = std::chrono::high_resolution_clock::now();\n    std::cout &lt;&lt; \"Vector iteration time: \"\n              &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start).count()\n              &lt;&lt; \" \u00b5s\\n\";\n\n    start = std::chrono::high_resolution_clock::now();\n    for (int i = 0; i &lt; ELEMENTS; i += 1000) {\n        volatile int x = vec[i];\n    }\n    end = std::chrono::high_resolution_clock::now();\n    std::cout &lt;&lt; \"Vector random access time: \"\n              &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start).count()\n              &lt;&lt; \" \u00b5s\\n\";\n}\n\nvoid benchmark_list() {\n    std::list&lt;int&gt; lst;\n\n    auto start = std::chrono::high_resolution_clock::now();\n    for (int i = 0; i &lt; ELEMENTS; ++i) {\n        lst.push_back(i);\n    }\n    auto end = std::chrono::high_resolution_clock::now();\n    std::cout &lt;&lt; \"List push_back time: \"\n              &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start).count()\n              &lt;&lt; \" \u00b5s\\n\";\n\n    start = std::chrono::high_resolution_clock::now();\n    for (const auto&amp; val : lst) {\n        volatile int x = val;\n    }\n    end = std::chrono::high_resolution_clock::now();\n    std::cout &lt;&lt; \"List iteration time: \"\n              &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start).count()\n              &lt;&lt; \" \u00b5s\\n\";\n\n    start = std::chrono::high_resolution_clock::now();\n    auto it = lst.begin();\n    for (int i = 0; i &lt; ELEMENTS; i += 1000) {\n        std::advance(it, 1000);\n        volatile int x = *it;\n    }\n    end = std::chrono::high_resolution_clock::now();\n    std::cout &lt;&lt; \"List pseudo-random access time (advance iterator): \"\n              &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start).count()\n              &lt;&lt; \" \u00b5s\\n\";\n}\n\nvoid benchmark_set() {\n    std::set&lt;int&gt; s;\n\n    auto start = std::chrono::high_resolution_clock::now();\n    for (int i = 0; i &lt; ELEMENTS; ++i) {\n        s.insert(i);\n    }\n    auto end = std::chrono::high_resolution_clock::now();\n    std::cout &lt;&lt; \"Set insertion time: \"\n              &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start).count()\n              &lt;&lt; \" \u00b5s\\n\";\n\n    start = std::chrono::high_resolution_clock::now();\n    for (const auto&amp; val : s) {\n        volatile int x = val;\n    }\n    end = std::chrono::high_resolution_clock::now();\n    std::cout &lt;&lt; \"Set iteration time: \"\n              &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start).count()\n              &lt;&lt; \" \u00b5s\\n\";\n\n    start = std::chrono::high_resolution_clock::now();\n    for (int i = 0; i &lt; ELEMENTS; i += 1000) {\n        volatile bool found = s.find(i) != s.end();\n    }\n    end = std::chrono::high_resolution_clock::now();\n    std::cout &lt;&lt; \"Set lookup time: \"\n              &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start).count()\n              &lt;&lt; \" \u00b5s\\n\";\n}\n\nvoid benchmark_unordered_set() {\n    std::unordered_set&lt;int&gt; us;\n\n    auto start = std::chrono::high_resolution_clock::now();\n    for (int i = 0; i &lt; ELEMENTS; ++i) {\n        us.insert(i);\n    }\n    auto end = std::chrono::high_resolution_clock::now();\n    std::cout &lt;&lt; \"Unordered Set insertion time: \"\n              &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start).count()\n              &lt;&lt; \" \u00b5s\\n\";\n\n    start = std::chrono::high_resolution_clock::now();\n    for (const auto&amp; val : us) {\n        volatile int x = val;\n    }\n    end = std::chrono::high_resolution_clock::now();\n    std::cout &lt;&lt; \"Unordered Set iteration time: \"\n              &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start).count()\n              &lt;&lt; \" \u00b5s\\n\";\n\n    start = std::chrono::high_resolution_clock::now();\n    for (int i = 0; i &lt; ELEMENTS; i += 1000) {\n        volatile bool found = us.find(i) != us.end();\n    }\n    end = std::chrono::high_resolution_clock::now();\n    std::cout &lt;&lt; \"Unordered Set lookup time: \"\n              &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start).count()\n              &lt;&lt; \" \u00b5s\\n\";\n}\n\nint main() {\n    std::cout &lt;&lt; \"Benchmarking std::vector vs std::list vs std::set vs std::unordered_set\\n\";\n\n    std::cout &lt;&lt; \"\\n--- std::vector ---\\n\";\n    benchmark_vector();\n\n    std::cout &lt;&lt; \"\\n--- std::list ---\\n\";\n    benchmark_list();\n\n    std::cout &lt;&lt; \"\\n--- std::set ---\\n\";\n    benchmark_set();\n\n    std::cout &lt;&lt; \"\\n--- std::unordered_set ---\\n\";\n    benchmark_unordered_set();\n\n    return 0;\n}\n</code></pre>"},{"location":"cpp/iterator/","title":"C++ Iterators","text":"<p>Iterators are a core concept in C++ that provide a uniform way to traverse through various container types (like arrays, vectors, lists, maps, etc.) without needing to know the underlying implementation details.</p>"},{"location":"cpp/iterator/#basic-iterator-concepts","title":"Basic Iterator Concepts","text":"<p>Iterators act as a bridge between algorithms and containers:</p> <pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};\n\n    // Iterator declaration\n    std::vector&lt;int&gt;::iterator it;\n\n    // Traversing using iterators\n    for (it = numbers.begin(); it != numbers.end(); ++it) {\n        std::cout &lt;&lt; *it &lt;&lt; \" \";  // Dereferencing to access the value\n    }\n    // Output: 1 2 3 4 5\n\n    // Alternative with auto (C++11)\n    for (auto it = numbers.begin(); it != numbers.end(); ++it) {\n        std::cout &lt;&lt; *it &lt;&lt; \" \";  \n    }\n}\n</code></pre>"},{"location":"cpp/iterator/#iterator-hierarchy","title":"Iterator Hierarchy","text":"<p>C++ provides several categories of iterators with increasing capabilities:</p>"},{"location":"cpp/iterator/#1-input-iterators","title":"1. Input Iterators","text":"<p>Input iterators can read elements from a sequence, moving only forward one step at a time and supporting only a single pass through the data.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;iterator&gt;\n\nint main() {\n    // std::istream_iterator is an input iterator\n    std::istringstream input(\"1 2 3 4 5\");\n    std::istream_iterator&lt;int&gt; it(input);  // Points to first int\n    std::istream_iterator&lt;int&gt; end;        // End-of-stream iterator\n\n    // Read from input stream one element at a time\n    while (it != end) {\n        std::cout &lt;&lt; \"Read: \" &lt;&lt; *it &lt;&lt; std::endl;\n        ++it;  // Move to next element (can't go back)\n    }\n\n    // Can't reset or reuse the iterator - single pass only\n}\n</code></pre>"},{"location":"cpp/iterator/#2-output-iterators","title":"2. Output Iterators","text":"<p>Output iterators can write elements to a destination sequence, moving only forward and supporting only a single pass.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nint main() {\n    std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};\n\n    // std::ostream_iterator is an output iterator\n    std::ostream_iterator&lt;int&gt; output_it(std::cout, \" \");\n\n    // Copy elements to output stream\n    std::copy(data.begin(), data.end(), output_it);\n    // Output: 1 2 3 4 5\n\n    // Using with algorithms\n    std::vector&lt;int&gt; squares;\n    std::back_insert_iterator&lt;std::vector&lt;int&gt;&gt; back_it(squares);\n    // Or simply: auto back_it = std::back_inserter(squares);\n\n    // Transform and insert at back\n    std::transform(data.begin(), data.end(), back_it,\n                  [](int x) { return x * x; });\n\n    // View results\n    for (int num : squares) {\n        std::cout &lt;&lt; num &lt;&lt; \" \";\n    }\n    // Output: 1 4 9 16 25\n}\n</code></pre>"},{"location":"cpp/iterator/#3-forward-iterators","title":"3. Forward Iterators","text":"<p>Forward iterators can both read and write elements, moving only forward but supporting multiple passes.</p> <pre><code>#include &lt;forward_list&gt;  // Singly-linked list\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nint main() {\n    // std::forward_list provides forward iterators\n    std::forward_list&lt;int&gt; flist = {1, 2, 3, 4, 5};\n\n    // Forward traversal\n    std::forward_list&lt;int&gt;::iterator it = flist.begin();\n    std::cout &lt;&lt; *it &lt;&lt; std::endl;  // 1\n    ++it;\n    std::cout &lt;&lt; *it &lt;&lt; std::endl;  // 2\n\n    // Can't go backwards: --it; // Error!\n\n    // But can make multiple passes\n    for (auto it1 = flist.begin(); it1 != flist.end(); ++it1) {\n        std::cout &lt;&lt; \"First pass: \" &lt;&lt; *it1 &lt;&lt; std::endl;\n    }\n\n    for (auto it2 = flist.begin(); it2 != flist.end(); ++it2) {\n        std::cout &lt;&lt; \"Second pass: \" &lt;&lt; *it2 &lt;&lt; std::endl;\n    }\n\n    // Can modify values in-place\n    for (auto it = flist.begin(); it != flist.end(); ++it) {\n        *it = *it * 2;\n    }\n\n    // View modified list\n    for (int val : flist) {\n        std::cout &lt;&lt; val &lt;&lt; \" \";  // 2 4 6 8 10\n    }\n}\n</code></pre>"},{"location":"cpp/iterator/#4-bidirectional-iterators","title":"4. Bidirectional Iterators","text":"<p>Bidirectional iterators can move both forward and backward, reading and writing elements with multiple passes.</p> <pre><code>#include &lt;list&gt;  // Doubly-linked list\n#include &lt;iostream&gt;\n\nint main() {\n    // std::list provides bidirectional iterators\n    std::list&lt;int&gt; dlist = {10, 20, 30, 40, 50};\n\n    // Bidirectional traversal\n    std::list&lt;int&gt;::iterator it = dlist.begin();\n    ++it;  // Forward to 20\n    ++it;  // Forward to 30\n    std::cout &lt;&lt; *it &lt;&lt; std::endl;  // 30\n\n    --it;  // Backward to 20\n    std::cout &lt;&lt; *it &lt;&lt; std::endl;  // 20\n\n    // Traverse backward through entire list\n    auto rit = dlist.end();\n    while (rit != dlist.begin()) {\n        --rit;  // Have to predecrement since end() is past-the-end\n        std::cout &lt;&lt; *rit &lt;&lt; \" \";\n    }\n    // Output: 50 40 30 20 10\n}\n</code></pre>"},{"location":"cpp/iterator/#5-random-access-iterators","title":"5. Random Access Iterators","text":"<p>Random access iterators provide all iterator operations plus direct access to any element with constant time complexity.</p> <pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    // std::vector provides random access iterators\n    std::vector&lt;int&gt; vec = {10, 20, 30, 40, 50};\n\n    // Random access operations\n    std::vector&lt;int&gt;::iterator it = vec.begin();\n\n    // Direct offset access\n    std::cout &lt;&lt; it[2] &lt;&lt; std::endl;     // 30 (like array access)\n    std::cout &lt;&lt; *(it + 3) &lt;&lt; std::endl; // 40 (pointer arithmetic)\n\n    // Jump directly to an element\n    it += 4;  // Jump to the 5th element\n    std::cout &lt;&lt; *it &lt;&lt; std::endl;  // 50\n\n    // Jump backward\n    it -= 2;  // Go back to the 3rd element\n    std::cout &lt;&lt; *it &lt;&lt; std::endl;  // 30\n\n    // Iterator arithmetic\n    auto it2 = vec.begin();\n    std::cout &lt;&lt; \"Distance: \" &lt;&lt; it - it2 &lt;&lt; std::endl;  // 2\n\n    // Comparison operators\n    std::cout &lt;&lt; \"it &gt; it2: \" &lt;&lt; (it &gt; it2) &lt;&lt; std::endl;  // 1 (true)\n    std::cout &lt;&lt; \"it &lt; vec.end(): \" &lt;&lt; (it &lt; vec.end()) &lt;&lt; std::endl;  // 1 (true)\n}\n</code></pre>"},{"location":"cpp/iterator/#common-iterator-operations","title":"Common Iterator Operations","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;iterator&gt;  // For std::distance\n\nint main() {\n    std::vector&lt;int&gt; numbers = {10, 20, 30, 40, 50};\n    auto it = numbers.begin();  // Modern style using auto\n\n    // Basic operations\n    std::cout &lt;&lt; *it &lt;&lt; std::endl;    // Dereferencing: 10\n    ++it;                             // Move to next element (prefer over it++)\n    std::cout &lt;&lt; *it &lt;&lt; std::endl;    // 20\n\n    it += 2;                          // Jump forward by 2 (random access)\n    std::cout &lt;&lt; *it &lt;&lt; std::endl;    // 40\n\n    --it;                             // Move backward\n    std::cout &lt;&lt; *it &lt;&lt; std::endl;    // 30\n\n    // Iterator arithmetic (for random access iterators)\n    auto it2 = numbers.begin();\n    std::cout &lt;&lt; \"Distance: \" &lt;&lt; it - it2 &lt;&lt; std::endl;  // 2\n\n    // For non-random access iterators, use std::distance\n    std::cout &lt;&lt; \"Distance: \" &lt;&lt; std::distance(it2, it) &lt;&lt; std::endl;  // 2\n\n    // Comparing iterators\n    if (it != numbers.end()) {\n        std::cout &lt;&lt; \"Not at the end yet\\n\";\n    }\n\n    // Advancing iterators (works for all iterator types)\n    std::advance(it, 1);  // Move forward 1 step to 40\n    std::cout &lt;&lt; *it &lt;&lt; std::endl;\n\n    // Getting next/prev iterators (C++11)\n    auto next_it = std::next(it);      // Iterator to the next element\n    auto prev_it = std::prev(it);      // Iterator to the previous element\n\n    std::cout &lt;&lt; *next_it &lt;&lt; std::endl;  // 50\n    std::cout &lt;&lt; *prev_it &lt;&lt; std::endl;  // 30\n}\n</code></pre>"},{"location":"cpp/iterator/#container-specific-iterators","title":"Container-Specific Iterators","text":"<p>Different containers provide specific types of iterators:</p> <pre><code>#include &lt;vector&gt;\n#include &lt;list&gt;\n#include &lt;map&gt;\n#include &lt;set&gt;\n#include &lt;unordered_map&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    // Vector - random access\n    std::vector&lt;int&gt; vec = {1, 2, 3};\n    std::vector&lt;int&gt;::iterator vec_it = vec.begin();\n    vec_it += 2;  // Random access - jumps directly to element 3\n    std::cout &lt;&lt; \"Vector element: \" &lt;&lt; *vec_it &lt;&lt; std::endl;\n\n    // List - bidirectional only\n    std::list&lt;int&gt; lst = {1, 2, 3};\n    std::list&lt;int&gt;::iterator lst_it = lst.begin();\n    ++lst_it;     // Forward one step\n    --lst_it;     // Backward one step\n    std::cout &lt;&lt; \"List element: \" &lt;&lt; *lst_it &lt;&lt; std::endl;\n    // lst_it += 2;  // Error! List iterators don't support random access\n\n    // Set - bidirectional, elements are const\n    std::set&lt;int&gt; s = {3, 1, 4};  // Sorted automatically: 1, 3, 4\n    auto set_it = s.begin();\n    std::cout &lt;&lt; \"First set element: \" &lt;&lt; *set_it &lt;&lt; std::endl;  // 1\n    // *set_it = 5;  // Error! Can't modify set elements through iterator\n\n    // Map - bidirectional\n    std::map&lt;std::string, int&gt; ages = {{\"Alice\", 25}, {\"Bob\", 30}, {\"Charlie\", 35}};\n    std::map&lt;std::string, int&gt;::iterator map_it = ages.begin();\n    // Maps iterate through key-value pairs as std::pair objects\n    std::cout &lt;&lt; map_it-&gt;first &lt;&lt; \": \" &lt;&lt; map_it-&gt;second &lt;&lt; std::endl;\n    // Output: Alice: 25 (maps are sorted by key)\n\n    // Increment to next entry\n    ++map_it;\n    std::cout &lt;&lt; map_it-&gt;first &lt;&lt; \": \" &lt;&lt; map_it-&gt;second &lt;&lt; std::endl;\n    // Output: Bob: 30\n\n    // Modifying map values (but not keys)\n    map_it-&gt;second = 31;  // Change Bob's age\n\n    // Unordered containers - forward iterators\n    std::unordered_map&lt;std::string, int&gt; hash_map = {{\"X\", 1}, {\"Y\", 2}};\n    // Order not guaranteed\n    for (auto it = hash_map.begin(); it != hash_map.end(); ++it) {\n        std::cout &lt;&lt; it-&gt;first &lt;&lt; \": \" &lt;&lt; it-&gt;second &lt;&lt; std::endl;\n    }\n}\n</code></pre>"},{"location":"cpp/iterator/#const-iterators","title":"Const Iterators","text":"<p>When you only need read access, use <code>const_iterator</code> for safety:</p> <pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};\n\n    // Three ways to get const iterators:\n\n    // 1. From non-const container using cbegin()/cend() (C++11)\n    auto it1 = numbers.cbegin();\n\n    // 2. Explicitly declare const_iterator type\n    std::vector&lt;int&gt;::const_iterator it2 = numbers.begin();\n\n    // 3. From const container (all iterators are const)\n    const std::vector&lt;int&gt;&amp; const_numbers = numbers;\n    auto it3 = const_numbers.begin();  // const_iterator automatically\n\n    // Read but can't modify\n    std::cout &lt;&lt; *it1 &lt;&lt; std::endl;  // OK\n    // *it1 = 10;  // Error! Cannot modify through const_iterator\n\n    // Traversing with const_iterator\n    for (auto it = numbers.cbegin(); it != numbers.cend(); ++it) {\n        std::cout &lt;&lt; *it &lt;&lt; \" \";\n        // *it += 1;  // Error! Cannot modify through const_iterator\n    }\n\n    // Modern C++11 range-based for loop with const reference\n    // (implicitly uses const iterators)\n    for (const int&amp; num : numbers) {\n        std::cout &lt;&lt; num &lt;&lt; \" \";\n        // num = 10;  // Error! Can't modify through const reference\n    }\n}\n</code></pre>"},{"location":"cpp/iterator/#reverse-iterators","title":"Reverse Iterators","text":"<p>To traverse containers in reverse order:</p> <pre><code>#include &lt;vector&gt;\n#include &lt;list&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nint main() {\n    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};\n\n    // Using reverse iterators\n    std::cout &lt;&lt; \"Reverse traversal: \";\n    for (auto rit = numbers.rbegin(); rit != numbers.rend(); ++rit) {\n        std::cout &lt;&lt; *rit &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n    // Output: 5 4 3 2 1\n\n    // Explicitly typed reverse iterator\n    std::vector&lt;int&gt;::reverse_iterator rev_it = numbers.rbegin();\n    std::cout &lt;&lt; \"First element from end: \" &lt;&lt; *rev_it &lt;&lt; std::endl;  // 5\n\n    // Const reverse iterator\n    std::vector&lt;int&gt;::const_reverse_iterator const_rev_it = numbers.crbegin();\n    std::cout &lt;&lt; \"Using const reverse iterator: \" &lt;&lt; *const_rev_it &lt;&lt; std::endl;\n\n    // Converting reverse iterator to forward iterator with base()\n    auto normal_it = (++numbers.rbegin()).base();\n    std::cout &lt;&lt; \"Element via base(): \" &lt;&lt; *normal_it &lt;&lt; std::endl;  // 4\n\n    // Using reverse iterators with algorithms\n    std::vector&lt;int&gt; reversed(numbers.size());\n    std::copy(numbers.rbegin(), numbers.rend(), reversed.begin());\n\n    std::cout &lt;&lt; \"Reversed vector: \";\n    for (int num : reversed) {\n        std::cout &lt;&lt; num &lt;&lt; \" \";  // 5 4 3 2 1\n    }\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"cpp/iterator/#iterator-invalidation","title":"Iterator Invalidation","text":"<p>Be careful about iterator invalidation when modifying containers:</p> <pre><code>#include &lt;vector&gt;\n#include &lt;list&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    // Vector iterator invalidation examples\n    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};\n    auto it = vec.begin() + 2;  // Points to 3\n    std::cout &lt;&lt; \"Before modification: \" &lt;&lt; *it &lt;&lt; std::endl;  // 3\n\n    // Adding elements (may cause reallocation)\n    vec.push_back(6);  // May invalidate ALL iterators if reallocation occurs\n\n    // DANGER: 'it' may now be invalid!\n    // std::cout &lt;&lt; *it &lt;&lt; std::endl;  // Undefined behavior!\n\n    // Safe: reacquire iterator after modification\n    it = vec.begin() + 2;\n    std::cout &lt;&lt; \"After reacquiring: \" &lt;&lt; *it &lt;&lt; std::endl;  // 3\n\n    // Erasing elements invalidates iterators to erased elements and beyond\n    auto erase_it = vec.begin() + 1;  // Points to 2\n    vec.erase(erase_it);  // Removes 2, invalidates erase_it and all following iterators\n\n    // Safe: iterator returned by erase\n    erase_it = vec.erase(vec.begin());  // Removes 1, returns iterator to next element\n    std::cout &lt;&lt; \"After erase: \" &lt;&lt; *erase_it &lt;&lt; std::endl;  // 3\n\n    // List has more stable iterators\n    std::list&lt;int&gt; lst = {10, 20, 30, 40, 50};\n    auto lst_it = lst.begin();\n    ++lst_it;  // Points to 20\n    ++lst_it;  // Points to 30\n    std::cout &lt;&lt; \"List iterator: \" &lt;&lt; *lst_it &lt;&lt; std::endl;  // 30\n\n    // List insertion doesn't invalidate existing iterators\n    lst.push_back(60);\n    lst.push_front(5);\n    std::cout &lt;&lt; \"Still valid: \" &lt;&lt; *lst_it &lt;&lt; std::endl;  // Still 30\n\n    // List erasure only invalidates iterators to erased elements\n    auto another_it = lst.begin();\n    ++another_it;  // Points to 10\n    lst.erase(another_it);  // Only invalidates the iterator to 10\n    std::cout &lt;&lt; \"Still valid after erase: \" &lt;&lt; *lst_it &lt;&lt; std::endl;  // Still 30\n}\n</code></pre>"},{"location":"cpp/iterator/#modern-c-range-based-for-loops","title":"Modern C++ Range-Based For Loops","text":"<p>C++11 introduced range-based for loops as a simpler way to iterate:</p> <pre><code>#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};\n\n    // Simple element access (copies elements)\n    std::cout &lt;&lt; \"By value: \";\n    for (int number : numbers) {\n        std::cout &lt;&lt; number &lt;&lt; \" \";\n        // Modifying number doesn't affect the container\n        number *= 2;\n    }\n    std::cout &lt;&lt; std::endl;\n\n    // Modifying elements using reference\n    std::cout &lt;&lt; \"By reference: \";\n    for (int&amp; number : numbers) {\n        number *= 2;  // Modifies the actual container elements\n        std::cout &lt;&lt; number &lt;&lt; \" \";  // 2 4 6 8 10\n    }\n    std::cout &lt;&lt; std::endl;\n\n    // Read-only access with const reference (most efficient)\n    std::cout &lt;&lt; \"By const reference: \";\n    for (const int&amp; number : numbers) {\n        std::cout &lt;&lt; number &lt;&lt; \" \";  // 2 4 6 8 10\n        // number = 1;  // Error! Can't modify a const reference\n    }\n    std::cout &lt;&lt; std::endl;\n\n    // Works with all container types\n    std::map&lt;std::string, int&gt; ages = {{\"Alice\", 25}, {\"Bob\", 30}, {\"Charlie\", 35}};\n\n    for (const auto&amp; pair : ages) {\n        std::cout &lt;&lt; pair.first &lt;&lt; \" is \" &lt;&lt; pair.second &lt;&lt; \" years old.\" &lt;&lt; std::endl;\n    }\n\n    // C++17 structured binding for map iteration\n    for (const auto&amp; [name, age] : ages) {\n        std::cout &lt;&lt; name &lt;&lt; \" is \" &lt;&lt; age &lt;&lt; \" years old.\" &lt;&lt; std::endl;\n    }\n}\n</code></pre>"},{"location":"cpp/iterator/#iterator-algorithms-with-algorithm","title":"Iterator Algorithms with <code>&lt;algorithm&gt;</code>","text":"<p>The standard library provides powerful algorithms using iterators:</p> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;numeric&gt;\n#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n\nint main() {\n    std::vector&lt;int&gt; numbers = {5, 2, 8, 1, 9};\n\n    // Sorting\n    std::sort(numbers.begin(), numbers.end());\n    std::cout &lt;&lt; \"Sorted: \";\n    for (int n : numbers) std::cout &lt;&lt; n &lt;&lt; \" \";  // 1 2 5 8 9\n    std::cout &lt;&lt; std::endl;\n\n    // Finding elements\n    auto it = std::find(numbers.begin(), numbers.end(), 5);\n    if (it != numbers.end()) {\n        std::cout &lt;&lt; \"Found 5 at position: \" \n                  &lt;&lt; std::distance(numbers.begin(), it) &lt;&lt; std::endl;  // 2\n    }\n\n    // Counting elements matching a condition\n    int count = std::count_if(numbers.begin(), numbers.end(), \n                             [](int x) { return x % 2 == 0; });\n    std::cout &lt;&lt; \"Even numbers: \" &lt;&lt; count &lt;&lt; std::endl;  // 1 (only 2 is even)\n\n    // Transforming elements\n    std::vector&lt;int&gt; squares(numbers.size());\n    std::transform(numbers.begin(), numbers.end(), squares.begin(),\n                  [](int x) { return x * x; });\n\n    std::cout &lt;&lt; \"Squares: \";\n    for (int n : squares) std::cout &lt;&lt; n &lt;&lt; \" \";  // 1 4 25 64 81\n    std::cout &lt;&lt; std::endl;\n\n    // Accumulating values\n    int sum = std::accumulate(numbers.begin(), numbers.end(), 0);\n    std::cout &lt;&lt; \"Sum: \" &lt;&lt; sum &lt;&lt; std::endl;  // 25\n\n    // Filtering with back_inserter\n    std::vector&lt;int&gt; even_nums;\n    std::copy_if(numbers.begin(), numbers.end(), \n                std::back_inserter(even_nums),\n                [](int x) { return x % 2 == 0; });\n\n    std::cout &lt;&lt; \"Even: \";\n    for (int n : even_nums) std::cout &lt;&lt; n &lt;&lt; \" \";  // 2 8\n    std::cout &lt;&lt; std::endl;\n\n    // Using inserter with sets\n    std::set&lt;int&gt; num_set;\n    std::copy(numbers.begin(), numbers.end(), \n             std::inserter(num_set, num_set.end()));\n\n    // Using direct output\n    std::cout &lt;&lt; \"To output: \";\n    std::copy(numbers.begin(), numbers.end(), \n             std::ostream_iterator&lt;int&gt;(std::cout, \" \"));\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"cpp/iterator/#iterator-adaptors","title":"Iterator Adaptors","text":"<p>C++ provides several iterator adaptors to enhance functionality:</p> <pre><code>#include &lt;vector&gt;\n#include &lt;list&gt;\n#include &lt;iterator&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nint main() {\n    std::vector&lt;int&gt; vec;\n\n    // back_inserter - adds elements to the end of a container\n    std::generate_n(std::back_inserter(vec), 5, \n                   [n = 0]() mutable { return ++n; });\n\n    std::cout &lt;&lt; \"After back_inserter: \";\n    for (int n : vec) std::cout &lt;&lt; n &lt;&lt; \" \";  // 1 2 3 4 5\n    std::cout &lt;&lt; std::endl;\n\n    // front_inserter - adds elements to the beginning (not for vector)\n    std::list&lt;int&gt; lst;\n    std::generate_n(std::front_inserter(lst), 3, \n                   [n = 10]() mutable { return n--; });\n\n    std::cout &lt;&lt; \"After front_inserter: \";\n    for (int n : lst) std::cout &lt;&lt; n &lt;&lt; \" \";  // 8 9 10\n    std::cout &lt;&lt; std::endl;\n\n    // inserter - inserts at a specific position\n    std::vector&lt;int&gt; dest = {1, 5};\n    std::vector&lt;int&gt; source = {2, 3, 4};\n\n    // Insert source elements into dest at position 1\n    std::copy(source.begin(), source.end(), \n             std::inserter(dest, dest.begin() + 1));\n\n    std::cout &lt;&lt; \"After inserter: \";\n    for (int n : dest) std::cout &lt;&lt; n &lt;&lt; \" \";  // 1 2 3 4 5\n    std::cout &lt;&lt; std::endl;\n\n    // move_iterator - moves elements instead of copying\n    std::vector&lt;std::string&gt; src = {\"Hello\", \"World\"};\n    std::vector&lt;std::string&gt; dst;\n\n    // Move strings instead of copying them\n    std::copy(std::make_move_iterator(src.begin()),\n             std::make_move_iterator(src.end()),\n             std::back_inserter(dst));\n\n    std::cout &lt;&lt; \"dst[0]: \" &lt;&lt; dst[0] &lt;&lt; std::endl;  // Hello\n    std::cout &lt;&lt; \"src[0] empty? \" &lt;&lt; src[0].empty() &lt;&lt; std::endl;  // Likely 1 (true)\n}\n</code></pre>"},{"location":"cpp/iterator/#custom-iterators","title":"Custom Iterators","text":"<p>You can create your own iterators for custom containers:</p> <pre><code>#include &lt;iterator&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\n// Simple custom container\nclass IntContainer {\nprivate:\n    int data[10];\n\npublic:\n    IntContainer() {\n        for (int i = 0; i &lt; 10; i++) data[i] = i;\n    }\n\n    // Custom iterator class\n    class Iterator {\n    private:\n        int* ptr;\n\n    public:\n        // Iterator traits (required for algorithm compatibility)\n        using iterator_category = std::random_access_iterator_tag;\n        using value_type = int;\n        using difference_type = std::ptrdiff_t;\n        using pointer = int*;\n        using reference = int&amp;;\n\n        // Constructors\n        Iterator(int* p) : ptr(p) {}\n\n        // Basic operators\n        reference operator*() const { return *ptr; }\n        pointer operator-&gt;() const { return ptr; }\n\n        // Increment/decrement\n        Iterator&amp; operator++() { ++ptr; return *this; }  // Pre-increment\n        Iterator operator++(int) { Iterator tmp = *this; ++ptr; return tmp; }  // Post-increment\n\n        Iterator&amp; operator--() { --ptr; return *this; }  // Pre-decrement\n        Iterator operator--(int) { Iterator tmp = *this; --ptr; return tmp; }  // Post-decrement\n\n        // Random access operators\n        Iterator&amp; operator+=(difference_type n) { ptr += n; return *this; }\n        Iterator operator+(difference_type n) const { return Iterator(ptr + n); }\n\n        Iterator&amp; operator-=(difference_type n) { ptr -= n; return *this; }\n        Iterator operator-(difference_type n) const { return Iterator(ptr - n); }\n\n        difference_type operator-(const Iterator&amp; other) const {\n            return ptr - other.ptr;\n        }\n\n        reference operator[](difference_type n) const { return ptr[n]; }\n\n        // Comparison operators\n        friend bool operator==(const Iterator&amp; a, const Iterator&amp; b) {\n            return a.ptr == b.ptr;\n        }\n        friend bool operator!=(const Iterator&amp; a, const Iterator&amp; b) {\n            return a.ptr != b.ptr;\n        }\n\n        friend bool operator&lt;(const Iterator&amp; a, const Iterator&amp; b) {\n            return a.ptr &lt; b.ptr;\n        }\n        friend bool operator&gt;(const Iterator&amp; a, const Iterator&amp; b) {\n            return a.ptr &gt; b.ptr;\n        }\n        friend bool operator&lt;=(const Iterator&amp; a, const Iterator&amp; b) {\n            return a.ptr &lt;= b.ptr;\n        }\n        friend bool operator&gt;=(const Iterator&amp; a, const Iterator&amp; b) {\n            return a.ptr &gt;= b.ptr;\n        }\n\n        friend Iterator operator+(difference_type n, const Iterator&amp; it) {\n            return Iterator(it.ptr + n);\n        }\n    };\n\n    // Iterator factory methods\n    Iterator begin() { return Iterator(&amp;data[0]); }\n    Iterator end() { return Iterator(&amp;data[10]); }\n\n    // Const iterator version\n    class ConstIterator {\n    private:\n        const int* ptr;\n\n    public:\n        // Same traits but with const pointer/reference\n        using iterator_category = std::random_access_iterator_tag;\n        using value_type = int;\n        using difference_type = std::ptrdiff_t;\n        using pointer = const int*;\n        using reference = const int&amp;;\n\n        ConstIterator(const int* p) : ptr(p) {}\n\n        // Read-only access\n        reference operator*() const { return *ptr; }\n        pointer operator-&gt;() const { return ptr; }\n\n        // Other operators (similar to non-const version)\n        ConstIterator&amp; operator++() { ++ptr; return *this; }\n        // ... additional operators omitted for brevity\n    };\n\n    // Const iterator factory methods\n    ConstIterator begin() const { return ConstIterator(&amp;data[0]); }\n    ConstIterator end() const { return ConstIterator(&amp;data[10]); }\n};\n\nint main() {\n    IntContainer container;\n\n    // Using our custom iterator\n    std::cout &lt;&lt; \"Forward: \";\n    for (auto it = container.begin(); it != container.end(); ++it) {\n        std::cout &lt;&lt; *it &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n    // Output: 0 1 2 3 4 5 6 7 8 9\n\n    // Random access\n    auto it = container.begin();\n    it += 5;\n    std::cout &lt;&lt; \"Element at index 5: \" &lt;&lt; *it &lt;&lt; std::endl;  // 5\n\n    // Using STL algorithms with custom iterator\n    std::cout &lt;&lt; \"Sum: \" &lt;&lt; \n        std::accumulate(container.begin(), container.end(), 0) &lt;&lt; std::endl;  // 45\n\n    // Range-based for loop works if begin/end are properly defined\n    std::cout &lt;&lt; \"Range-based for: \";\n    for (int val : container) {\n        std::cout &lt;&lt; val &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"cpp/iterator/#iterator-best-practices","title":"Iterator Best Practices","text":"<ol> <li>Use the appropriate iterator type for your needs</li> <li><code>const_iterator</code> for read-only access</li> <li> <p>Regular iterators when you need to modify elements</p> </li> <li> <p>Be aware of iterator invalidation rules</p> </li> <li>Vector: Insertion/deletion invalidates iterators to elements at or after the point of insertion/deletion</li> <li> <p>List/Set/Map: Insertion doesn't invalidate existing iterators; deletion invalidates only iterators to the deleted elements</p> </li> <li> <p>Prefer modern C++ idioms</p> </li> <li>Use <code>auto</code> to simplify iterator declarations</li> <li>Use range-based for loops for simple iteration</li> <li> <p>Use algorithms from <code>&lt;algorithm&gt;</code> header with iterators</p> </li> <li> <p>Performance considerations</p> </li> <li>Prefer prefix increment (<code>++it</code>) over postfix (<code>it++</code>) for better performance</li> <li>Use <code>reserve()</code> on vectors before adding elements to prevent iterator invalidation</li> <li> <p>Pass large objects by const reference in range-based loops</p> </li> <li> <p>Safety tips</p> </li> <li>Always check if iterator is valid before dereferencing (not equal to <code>.end()</code>)</li> <li>Be cautious with iterator arithmetic to avoid going out of bounds</li> <li> <p>If modifying a container, reacquire iterators after operations that may invalidate them</p> </li> <li> <p>Iterator adapters</p> </li> <li>Use <code>std::back_inserter</code> and other inserters for flexible algorithms</li> <li> <p>Consider using iterator adapters for move semantics with <code>std::make_move_iterator</code></p> </li> <li> <p>Debug techniques</p> </li> <li>Check distances between iterators with <code>std::distance</code></li> <li>Convert iterators to indices for debugging using <code>std::distance</code></li> </ol>"},{"location":"cpp/lambda_function_bind/","title":"C++ Lambda Functions and Function Binding","text":""},{"location":"cpp/lambda_function_bind/#lambda-functions-in-c11","title":"Lambda Functions in C++11","text":"<p>Lambda functions (or lambda expressions) allow you to define anonymous function objects directly at the location where they are needed, typically as arguments to algorithms or custom callbacks.</p>"},{"location":"cpp/lambda_function_bind/#basic-syntax","title":"Basic Syntax","text":"<pre><code>[capture_list](parameters) -&gt; return_type { function_body }\n</code></pre> <ul> <li>Capture list: Specifies which variables from the surrounding scope are accessible within the lambda</li> <li>Parameters: Function parameters (like regular functions)</li> <li>Return type: Optional, compiler can deduce it in most cases</li> <li>Function body: The actual code to execute</li> </ul>"},{"location":"cpp/lambda_function_bind/#capture-options","title":"Capture Options","text":"<ul> <li><code>[]</code>: Capture nothing</li> <li><code>[=]</code>: Capture all variables by value</li> <li><code>[&amp;]</code>: Capture all variables by reference</li> <li><code>[x, &amp;y]</code>: Capture x by value, y by reference</li> <li><code>[=, &amp;z]</code>: Capture all by value, but z by reference</li> <li><code>[this]</code>: Capture the this pointer of the enclosing class</li> </ul>"},{"location":"cpp/lambda_function_bind/#examples","title":"Examples","text":""},{"location":"cpp/lambda_function_bind/#simple-lambda","title":"Simple Lambda","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nint main() {\n    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};\n\n    // Lambda to print each number\n    std::for_each(numbers.begin(), numbers.end(), [](int n) {\n        std::cout &lt;&lt; n &lt;&lt; \" \";\n    });\n    // Output: 1 2 3 4 5\n\n    return 0;\n}\n</code></pre>"},{"location":"cpp/lambda_function_bind/#lambda-with-captures","title":"Lambda with Captures","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nint main() {\n    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};\n    int multiplier = 3;\n    int sum = 0;\n\n    // Capture multiplier by value and sum by reference\n    std::for_each(numbers.begin(), numbers.end(), [multiplier, &amp;sum](int n) {\n        sum += n * multiplier;\n    });\n\n    std::cout &lt;&lt; \"Sum of all numbers multiplied by \" &lt;&lt; multiplier &lt;&lt; \": \" &lt;&lt; sum &lt;&lt; std::endl;\n    // Output: Sum of all numbers multiplied by 3: 45\n\n    return 0;\n}\n</code></pre>"},{"location":"cpp/lambda_function_bind/#mutable-lambda","title":"Mutable Lambda","text":"<p>By default, variables captured by value are const. Use the <code>mutable</code> keyword to modify them:</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int counter = 0;\n\n    // Without mutable (would cause compilation error):\n    // auto increment = [counter]() { counter++; return counter; };\n\n    // With mutable:\n    auto increment = [counter]() mutable { counter++; return counter; };\n\n    std::cout &lt;&lt; increment() &lt;&lt; std::endl; // Output: 1\n    std::cout &lt;&lt; increment() &lt;&lt; std::endl; // Output: 2\n    std::cout &lt;&lt; \"Original counter: \" &lt;&lt; counter &lt;&lt; std::endl; // Output: Original counter: 0\n\n    return 0;\n}\n</code></pre>"},{"location":"cpp/lambda_function_bind/#function-binding-in-c","title":"Function Binding in C++","text":"<p>Function binding creates function objects that invoke a target function with some arguments bound to specific values. There are several approaches to function binding in C++:</p>"},{"location":"cpp/lambda_function_bind/#1-function-pointers","title":"1. Function Pointers","text":"<p>The traditional way to refer to functions. They can point to functions but don't store state or bind arguments.</p> <pre><code>#include &lt;iostream&gt;\n\n// Function to be pointed to\nint add(int a, int b) {\n    return a + b;\n}\n\n// Function that accepts a function pointer\nint apply(int (*func)(int, int), int x, int y) {\n    return func(x, y);\n}\n\nint main() {\n    // Create a function pointer\n    int (*funcPtr)(int, int) = add;\n\n    // Use the function pointer directly\n    std::cout &lt;&lt; \"Direct call: \" &lt;&lt; funcPtr(5, 3) &lt;&lt; std::endl;  // Output: 8\n\n    // Pass the function pointer to another function\n    std::cout &lt;&lt; \"Through apply: \" &lt;&lt; apply(funcPtr, 5, 3) &lt;&lt; std::endl;  // Output: 8\n\n    return 0;\n}\n</code></pre> <p>Function pointers have limitations: - Cannot bind arguments (no partial application) - Cannot store state - Cannot point to member functions directly (require different syntax)</p>"},{"location":"cpp/lambda_function_bind/#2-function-objects-functors","title":"2. Function Objects (Functors)","text":"<p>Classes that overload the <code>operator()</code> to make instances callable like functions. They can store state.</p> <pre><code>#include &lt;iostream&gt;\n\n// A functor with state\nclass Adder {\nprivate:\n    int base;\n\npublic:\n    Adder(int base) : base(base) {}\n\n    // Call operator\n    int operator()(int x) const {\n        return base + x;\n    }\n};\n\nint main() {\n    // Create a functor with base 10\n    Adder add10(10);\n\n    // Use the functor\n    std::cout &lt;&lt; \"10 + 5 = \" &lt;&lt; add10(5) &lt;&lt; std::endl;  // Output: 15\n\n    return 0;\n}\n</code></pre>"},{"location":"cpp/lambda_function_bind/#3-member-function-pointers","title":"3. Member Function Pointers","text":"<p>Special pointers that can point to class member functions. They are more complex to use than regular function pointers.</p> <pre><code>#include &lt;iostream&gt;\n\nclass Calculator {\npublic:\n    int add(int a, int b) {\n        return a + b;\n    }\n\n    int subtract(int a, int b) {\n        return a - b;\n    }\n};\n\nint main() {\n    // Create a member function pointer\n    int (Calculator::*operation)(int, int) = &amp;Calculator::add;\n\n    // Create an instance of the class\n    Calculator calc;\n\n    // Call the member function through the pointer\n    std::cout &lt;&lt; \"Result: \" &lt;&lt; (calc.*operation)(5, 3) &lt;&lt; std::endl;  // Output: 8\n\n    // Change the pointer to point to a different member function\n    operation = &amp;Calculator::subtract;\n    std::cout &lt;&lt; \"Result: \" &lt;&lt; (calc.*operation)(5, 3) &lt;&lt; std::endl;  // Output: 2\n\n    return 0;\n}\n</code></pre>"},{"location":"cpp/lambda_function_bind/#4-stdbind","title":"4. std::bind","text":"<p>Introduced in C++11, <code>std::bind</code> creates a new callable object that forwards its arguments to another callable after transforming them according to specified rules.</p> <pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n\nvoid print(int a, int b, int c) {\n    std::cout &lt;&lt; a &lt;&lt; \", \" &lt;&lt; b &lt;&lt; \", \" &lt;&lt; c &lt;&lt; std::endl;\n}\n\nint main() {\n    using namespace std::placeholders; // For _1, _2, etc.\n\n    // Bind the first parameter to 10\n    auto bound1 = std::bind(print, 10, _1, _2);\n    bound1(20, 30); // Output: 10, 20, 30\n\n    // Reorder parameters\n    auto bound2 = std::bind(print, _2, _3, _1);\n    bound2(100, 200, 300); // Output: 200, 300, 100\n\n    // Bind all parameters\n    auto bound3 = std::bind(print, 1, 2, 3);\n    bound3(); // Output: 1, 2, 3\n\n    return 0;\n}\n</code></pre>"},{"location":"cpp/lambda_function_bind/#5-stdfunction","title":"5. std::function","text":"<p>Introduced in C++11, <code>std::function</code> is a general-purpose polymorphic function wrapper that can store, copy, and invoke any callable object.</p> <pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n\n// Regular function\nint add(int a, int b) {\n    return a + b;\n}\n\n// Function object (functor)\nstruct Multiply {\n    int operator()(int a, int b) const {\n        return a * b;\n    }\n};\n\nint main() {\n    // Store regular function\n    std::function&lt;int(int, int)&gt; func1 = add;\n    std::cout &lt;&lt; \"func1(2, 3): \" &lt;&lt; func1(2, 3) &lt;&lt; std::endl; // Output: 5\n\n    // Store function object\n    std::function&lt;int(int, int)&gt; func2 = Multiply();\n    std::cout &lt;&lt; \"func2(2, 3): \" &lt;&lt; func2(2, 3) &lt;&lt; std::endl; // Output: 6\n\n    // Store lambda\n    std::function&lt;int(int, int)&gt; func3 = [](int a, int b) { return a - b; };\n    std::cout &lt;&lt; \"func3(5, 3): \" &lt;&lt; func3(5, 3) &lt;&lt; std::endl; // Output: 2\n\n    // Store the result of a bind expression\n    using namespace std::placeholders;\n    std::function&lt;int(int)&gt; func4 = std::bind(add, _1, 5);\n    std::cout &lt;&lt; \"func4(10): \" &lt;&lt; func4(10) &lt;&lt; std::endl; // Output: 15\n\n    return 0;\n}\n</code></pre>"},{"location":"cpp/lambda_function_bind/#6-lambda-functions","title":"6. Lambda Functions","text":"<p>Lambda functions provide a concise way to create function objects. They can capture context and are particularly useful for short, one-off functions.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nint main() {\n    int base = 10;\n\n    // Lambda that captures base by value\n    auto add = [base](int x) { return base + x; };\n\n    std::cout &lt;&lt; \"10 + 5 = \" &lt;&lt; add(5) &lt;&lt; std::endl;  // Output: 15\n\n    // Lambda without captures\n    auto multiply = [](int x, int y) { return x * y; };\n\n    std::cout &lt;&lt; \"3 * 4 = \" &lt;&lt; multiply(3, 4) &lt;&lt; std::endl;  // Output: 12\n\n    return 0;\n}\n</code></pre>"},{"location":"cpp/lambda_function_bind/#7-stdmem_fn-c11","title":"7. std::mem_fn (C++11)","text":"<p>Adapts a member function to be used with standard algorithms and function objects.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;functional&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nclass Person {\nprivate:\n    std::string name;\n    int age;\n\npublic:\n    Person(const std::string&amp; name, int age) : name(name), age(age) {}\n\n    int getAge() const { return age; }\n    std::string getName() const { return name; }\n};\n\nint main() {\n    std::vector&lt;Person&gt; people = {\n        Person(\"Alice\", 25),\n        Person(\"Bob\", 30),\n        Person(\"Charlie\", 20)\n    };\n\n    // Use mem_fn to create a callable that invokes getAge() on each object\n    std::vector&lt;int&gt; ages;\n    std::transform(people.begin(), people.end(), \n                  std::back_inserter(ages),\n                  std::mem_fn(&amp;Person::getAge));\n\n    for (int age : ages) {\n        std::cout &lt;&lt; \"Age: \" &lt;&lt; age &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"cpp/lambda_function_bind/#8-stdinvoke-c17","title":"8. std::invoke (C++17)","text":"<p>A unified way to call functions, member functions, and callable objects.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;functional&gt;\n\nstruct Foo {\n    void display() const {\n        std::cout &lt;&lt; \"Foo::display()\" &lt;&lt; std::endl;\n    }\n\n    int add(int a, int b) const {\n        return a + b;\n    }\n};\n\nvoid globalFunc(int x) {\n    std::cout &lt;&lt; \"Global function: \" &lt;&lt; x &lt;&lt; std::endl;\n}\n\nint main() {\n    // Invoke a free function\n    std::invoke(globalFunc, 42);  // Output: Global function: 42\n\n    Foo foo;\n\n    // Invoke a member function\n    std::invoke(&amp;Foo::display, foo);  // Output: Foo::display()\n\n    // Invoke a member function with arguments\n    int result = std::invoke(&amp;Foo::add, foo, 10, 20);\n    std::cout &lt;&lt; \"Result: \" &lt;&lt; result &lt;&lt; std::endl;  // Output: Result: 30\n\n    // Invoke a lambda\n    auto lambda = [](int x) { return x * x; };\n    std::cout &lt;&lt; \"Lambda result: \" &lt;&lt; std::invoke(lambda, 5) &lt;&lt; std::endl;  // Output: Lambda result: 25\n\n    return 0;\n}\n</code></pre>"},{"location":"cpp/lambda_function_bind/#combining-lambda-and-bind","title":"Combining Lambda and Bind","text":"<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nint main() {\n    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};\n    int threshold = 3;\n\n    // Using lambda\n    auto countWithLambda = std::count_if(numbers.begin(), numbers.end(), \n        [threshold](int n) { return n &gt; threshold; });\n\n    // Using bind with a lambda\n    auto isGreaterThan = [](int n, int t) { return n &gt; t; };\n    auto countWithBind = std::count_if(numbers.begin(), numbers.end(),\n        std::bind(isGreaterThan, std::placeholders::_1, threshold));\n\n    std::cout &lt;&lt; \"Count with lambda: \" &lt;&lt; countWithLambda &lt;&lt; std::endl; // Output: 2\n    std::cout &lt;&lt; \"Count with bind: \" &lt;&lt; countWithBind &lt;&lt; std::endl;     // Output: 2\n\n    return 0;\n}\n</code></pre>"},{"location":"cpp/lambda_function_bind/#comparison-of-function-binding-methods","title":"Comparison of Function Binding Methods","text":"Method Introduced Advantages Limitations Function Pointers C Simple, low overhead No state, no partial application Functors C++ Can store state, customizable Requires defining a class Member Function Pointers C++ Can call class methods Complex syntax, need class instance std::bind C++11 Argument binding, reordering More verbose than lambdas std::function C++11 Type erasure, generic wrapper Some overhead compared to direct calls Lambda Functions C++11 Concise, captures context Limited to their defined scope std::mem_fn C++11 Simplifies using member functions Only for member functions std::invoke C++17 Unified calling syntax Newer standard, may not be available"},{"location":"cpp/lambda_function_bind/#best-practices","title":"Best Practices","text":"<ul> <li>Modern C++ approach: Prefer lambdas for simple, local functions and std::function for more complex scenarios</li> <li>Performance: For performance-critical code, function pointers or functors might have less overhead</li> <li>Readability: Choose the method that makes your code most readable for the specific use case</li> <li>Flexibility: std::function provides the most flexibility but with some performance cost</li> <li>C++17 and beyond: Consider using std::invoke for a unified approach</li> </ul> <p>Both lambda expressions and function binding are powerful tools in modern C++ that make functional programming techniques more accessible and code more expressive.</p>"},{"location":"cpp/pointers/","title":"C++ Standard Pointers Tutorial","text":""},{"location":"cpp/pointers/#introduction","title":"Introduction","text":"<p>Pointers are a fundamental feature of C++ that allow direct memory manipulation. Understanding how to use pointers effectively is crucial for efficient memory management and preventing memory leaks. This tutorial covers raw pointers, smart pointers, and best practices for managing dynamic memory.</p>"},{"location":"cpp/pointers/#1-raw-pointers","title":"1. Raw Pointers","text":"<p>Raw pointers are the traditional way of handling dynamic memory in C++. They store memory addresses and allow direct access to memory.</p>"},{"location":"cpp/pointers/#declaring-and-using-pointers","title":"Declaring and Using Pointers","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a = 10;\n    int* ptr = &amp;a;  // Pointer storing the address of 'a'\n\n    cout &lt;&lt; \"Value of a: \" &lt;&lt; a &lt;&lt; endl;\n    cout &lt;&lt; \"Value using pointer: \" &lt;&lt; *ptr &lt;&lt; endl; // Dereferencing pointer\n\n    return 0;\n}\n</code></pre>"},{"location":"cpp/pointers/#dynamic-memory-allocation","title":"Dynamic Memory Allocation","text":"<p>Using <code>new</code> and <code>delete</code> to allocate and deallocate memory manually:</p> <pre><code>int* p = new int(5);  // Allocating memory for an integer\ncout &lt;&lt; *p &lt;&lt; endl;   // Accessing allocated memory\n\ndelete p;             // Deallocating memory\n</code></pre> <p>For arrays:</p> <pre><code>int* arr = new int[5]{1, 2, 3, 4, 5};  // Dynamic array allocation\n\ndelete[] arr;                          // Deallocate array memory\n</code></pre>"},{"location":"cpp/pointers/#issues-with-raw-pointers","title":"Issues with Raw Pointers","text":"<ul> <li>Memory Leaks: Forgetting to <code>delete</code> allocated memory leads to memory leaks.</li> <li>Dangling Pointers: Accessing memory after <code>delete</code> leads to undefined behavior.</li> <li>Manual Management: Requires explicit deallocation, which is error-prone.</li> </ul>"},{"location":"cpp/pointers/#2-smart-pointers-modern-c","title":"2. Smart Pointers (Modern C++)","text":"<p>C++ introduced smart pointers in <code>&lt;memory&gt;</code> to automate memory management and prevent leaks.</p>"},{"location":"cpp/pointers/#21-stdunique_ptr","title":"2.1 <code>std::unique_ptr</code>","text":"<p>A smart pointer that ensures single ownership of dynamically allocated memory.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\nusing namespace std;\n\nint main() {\n    unique_ptr&lt;int&gt; ptr = make_unique&lt;int&gt;(10);\n    cout &lt;&lt; \"Unique pointer value: \" &lt;&lt; *ptr &lt;&lt; endl;\n    return 0;\n} // Memory is automatically deallocated\n</code></pre> <ul> <li>Prevents manual <code>delete</code> calls.</li> <li>Ensures exclusive ownership (no copying allowed).</li> </ul>"},{"location":"cpp/pointers/#22-stdshared_ptr","title":"2.2 <code>std::shared_ptr</code>","text":"<p>Allows multiple smart pointers to share ownership of the same resource.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\nusing namespace std;\n\nint main() {\n    shared_ptr&lt;int&gt; sp1 = make_shared&lt;int&gt;(20);\n    shared_ptr&lt;int&gt; sp2 = sp1; // Both share ownership\n\n    cout &lt;&lt; \"Shared pointer value: \" &lt;&lt; *sp1 &lt;&lt; endl;\n    cout &lt;&lt; \"Reference count: \" &lt;&lt; sp1.use_count() &lt;&lt; endl;\n    return 0;\n} // Memory is deallocated when reference count reaches zero\n</code></pre> <ul> <li>Use only when multiple ownership is necessary.</li> </ul>"},{"location":"cpp/pointers/#23-stdweak_ptr","title":"2.3 <code>std::weak_ptr</code>","text":"<p>A weak reference to a <code>shared_ptr</code>, preventing circular references.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\nusing namespace std;\n\nint main() {\n    shared_ptr&lt;int&gt; sp = make_shared&lt;int&gt;(30);\n    weak_ptr&lt;int&gt; wp = sp;  // Does not increase reference count\n\n    if (auto locked = wp.lock()) { // Check if object is still available\n        cout &lt;&lt; \"Weak pointer value: \" &lt;&lt; *locked &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre> <ul> <li>Used to break cyclic dependencies in <code>shared_ptr</code> chains.</li> </ul>"},{"location":"cpp/pointers/#3-best-practices","title":"3. Best Practices","text":"<ol> <li>Prefer Smart Pointers: Use <code>unique_ptr</code> and <code>shared_ptr</code> instead of raw pointers for dynamic allocation.</li> <li>Use <code>make_unique</code> and <code>make_shared</code>: Avoid direct use of <code>new</code>.</li> <li>Avoid <code>shared_ptr</code> unless necessary: Overusing <code>shared_ptr</code> can lead to performance overhead.</li> <li>Reset or nullify pointers after deletion: Prevents dangling pointers.</li> </ol> <pre><code>ptr = nullptr; // Safe way to nul lify a pointer\n</code></pre> <ol> <li>Minimize the use of raw pointers: Use raw pointers only when necessary (e.g., working with legacy code or performance-critical applications).</li> </ol>"},{"location":"cpp/pointers/#conclusion","title":"Conclusion","text":"<p>Understanding C++ pointers is crucial for managing memory efficiently. While raw pointers provide flexibility, they require manual memory management. Modern C++ introduces smart pointers that simplify memory handling and reduce common pointer-related bugs. By following best practices, developers can write safer and more efficient C++ programs.</p>"},{"location":"cpp/return_value/","title":"C++ Return Values","text":""},{"location":"cpp/return_value/#basic-return-values","title":"Basic Return Values","text":"<p>In C++, functions can return values to the caller using the <code>return</code> statement. The return type is declared in the function signature.</p> <pre><code>int add(int a, int b) {\n    return a + b;  // Returns an integer\n}\n</code></pre>"},{"location":"cpp/return_value/#return-value-optimization-rvo","title":"Return Value Optimization (RVO)","text":"<p>Modern C++ compilers implement Return Value Optimization (RVO) which eliminates unnecessary copies when returning objects from functions.</p> <pre><code>std::vector&lt;int&gt; createVector() {\n    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};\n    return vec;  // No copying occurs with RVO\n}\n</code></pre>"},{"location":"cpp/return_value/#multiple-return-values","title":"Multiple Return Values","text":""},{"location":"cpp/return_value/#using-stdtuple","title":"Using std::tuple","text":"<pre><code>std::tuple&lt;int, double, std::string&gt; getValues() {\n    return {42, 3.14, \"hello\"};\n}\n\n// Usage\nauto [num, pi, greeting] = getValues();\n</code></pre>"},{"location":"cpp/return_value/#using-stdpair","title":"Using std::pair","text":"<pre><code>std::pair&lt;bool, std::string&gt; findElement(const std::vector&lt;std::string&gt;&amp; vec, const std::string&amp; elem) {\n    auto it = std::find(vec.begin(), vec.end(), elem);\n    if (it != vec.end()) {\n        return {true, *it};\n    }\n    return {false, \"\"};\n}\n</code></pre>"},{"location":"cpp/return_value/#using-structclass","title":"Using struct/class","text":"<pre><code>struct Result {\n    bool success;\n    int value;\n    std::string error;\n};\n\nResult compute() {\n    // Computation logic\n    return {true, 42, \"\"};\n}\n</code></pre>"},{"location":"cpp/return_value/#optional-return-values","title":"Optional Return Values","text":"<p>Using <code>std::optional</code> (C++17):</p> <pre><code>std::optional&lt;int&gt; divideIfPossible(int a, int b) {\n    if (b == 0) {\n        return std::nullopt;  // No value\n    }\n    return a / b;\n}\n\n// Usage\nauto result = divideIfPossible(10, 2);\nif (result.has_value()) {\n    std::cout &lt;&lt; \"Result: \" &lt;&lt; *result &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"cpp/return_value/#reference-return-values","title":"Reference Return Values","text":"<p>Functions can return references, but be careful about lifetime issues:</p> <pre><code>// Safe: returning reference to static data\nconst std::string&amp; getStaticString() {\n    static std::string str = \"Hello, world!\";\n    return str;\n}\n\n// Dangerous: returning reference to local variable\nstd::string&amp; getDangerousReference() {\n    std::string local = \"Danger!\";\n    return local;  // NEVER DO THIS - local will be destroyed\n}\n</code></pre>"},{"location":"cpp/return_value/#modifying-values-through-references","title":"Modifying Values Through References","text":"<p>Instead of returning a value, you can modify variables by passing them as references:</p> <pre><code>void modifyValue(int&amp; value) {\n    value = value * 2;  // Modifies the original variable\n}\n\n// Usage\nint x = 5;\nmodifyValue(x);  // x is now 10\n</code></pre>"},{"location":"cpp/return_value/#returning-shared-pointers","title":"Returning Shared Pointers","text":"<p>When you need to return dynamically allocated objects with shared ownership:</p> <pre><code>std::shared_ptr&lt;MyClass&gt; createSharedObject() {\n    return std::make_shared&lt;MyClass&gt;(/* constructor args */);\n}\n\n// Usage\nauto obj = createSharedObject();\n// No need to manually delete, memory will be freed when last shared_ptr is destroyed\n</code></pre>"},{"location":"cpp/return_value/#class-method-return-types-and-const","title":"Class Method Return Types and <code>const</code>","text":"<p>The <code>const</code> qualifier in method signatures affects how you can use and return values in class contexts:</p> <pre><code>class DataContainer {\nprivate:\n    std::vector&lt;int&gt; data;\n\npublic:\n    // Non-const method - returns modifiable reference\n    std::vector&lt;int&gt;&amp; getData() {\n        return data;  // Caller can modify the internal data\n    }\n\n    // Const method - must return const reference\n    const std::vector&lt;int&gt;&amp; getData() const {\n        return data;  // Caller cannot modify the internal data\n    }\n\n    // Value getter that works in both const and non-const contexts\n    int getSize() const {\n        return data.size();  // Returning by value is always safe\n    }\n\n    // Modification through reference parameter in non-const context\n    void processData(std::vector&lt;int&gt;&amp; result) {\n        // Fill result with processed data\n        result = data;  // Simplified example\n    }\n};\n\n// Usage:\nDataContainer container;\n// Non-const object can use both const and non-const methods\nauto&amp; modifiable = container.getData();  // Uses non-const version\nmodifiable[0] = 100;  // OK - modifies container's data\n\nconst DataContainer constContainer;\n// Const object can only use const methods\nconst auto&amp; readOnly = constContainer.getData();  // Uses const version\n// readOnly[0] = 100;  // Error - cannot modify const reference\n</code></pre>"},{"location":"cpp/return_value/#best-practices","title":"Best Practices","text":"<ol> <li>Use return value optimization by returning objects directly.</li> <li>Prefer returning by value for small objects.</li> <li>Consider using <code>std::optional</code> for functions that might not return a value.</li> <li>Be careful when returning references to ensure the referenced object outlives the reference.</li> <li>For multiple return values, use structured bindings with tuples or custom structs.</li> <li>Use reference parameters (like <code>void f(Type&amp; param)</code>) when you need to modify the original variable.</li> <li>Consider <code>std::shared_ptr</code> when returning dynamically allocated objects that need shared ownership.</li> </ol>"},{"location":"cpp/x/","title":"C++ Containers: A Comprehensive Guide","text":""},{"location":"cpp/x/#introduction","title":"Introduction","text":"<p>C++ provides a powerful set of container classes within the Standard Template Library (STL). These containers help manage collections of objects efficiently. Containers in C++ are broadly classified into sequence containers, associative containers, and unordered containers.</p>"},{"location":"cpp/x/#1-sequence-containers","title":"1. Sequence Containers","text":"<p>Sequence containers store elements in a linear fashion and allow efficient traversal.</p>"},{"location":"cpp/x/#11-stdvector-c98","title":"1.1 std::vector (C++98)","text":"<p>A dynamic array that grows as needed. It provides fast random access and efficient insertion/removal at the end.</p> Operation Time Complexity Access (by index) O(1) Insert at end Amortized O(1) Insert at middle O(n) Delete at end O(1) Delete at middle O(n) Get size O(1) <p>Example:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    std::vector&lt;int&gt; v = {1, 2, 3, 4, 5};\n    v.push_back(6);\n\n    for (int num : v) {\n        std::cout &lt;&lt; num &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"cpp/x/#12-stdlist-c98","title":"1.2 std::list (C++98)","text":"<p>A doubly linked list that allows efficient insertion and deletion at any position.</p> Operation Time Complexity Access (by index) O(n) Insert at end O(1) Insert at middle O(1) with iterator Delete at end O(1) Delete at middle O(1) with iterator Get size O(1) <p>Example:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;list&gt;\n\nint main() {\n    std::list&lt;int&gt; lst = {1, 2, 3};\n    lst.push_front(0);\n    lst.push_back(4);\n\n    for (int num : lst) {\n        std::cout &lt;&lt; num &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"cpp/x/#13-stddeque-c98","title":"1.3 std::deque (C++98)","text":"<p>A double-ended queue that supports fast insertions and deletions at both ends.</p> Operation Time Complexity Access (by index) O(1) Insert at end O(1) Insert at middle O(n) Delete at end O(1) Delete at middle O(n) Get size O(1) <p>Example:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;deque&gt;\n\nint main() {\n    std::deque&lt;int&gt; dq = {2, 3, 4};\n    dq.push_front(1);\n    dq.push_back(5);\n\n    for (int num : dq) {\n        std::cout &lt;&lt; num &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"cpp/x/#2-associative-containers","title":"2. Associative Containers","text":"<p>Associative containers store elements in a sorted order based on keys.</p>"},{"location":"cpp/x/#21-stdset-c98","title":"2.1 std::set (C++98)","text":"<p>A sorted collection of unique elements.</p> Operation Time Complexity Access (by index) O(n) Insert at end N/A Insert at middle O(log n) Delete at end N/A Delete at middle O(log n) Get size O(1) <p>Example:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nint main() {\n    std::set&lt;int&gt; s = {4, 2, 5, 1, 3};\n    s.insert(3);\n\n    for (int num : s) {\n        std::cout &lt;&lt; num &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"cpp/x/#22-stdmap-c98","title":"2.2 std::map (C++98)","text":"<p>A key-value pair container sorted by keys.</p> Operation Time Complexity Access (by index) O(log n) Insert at end N/A Insert at middle O(log n) Delete at end N/A Delete at middle O(log n) Get size O(1) <p>Example:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nint main() {\n    std::map&lt;int, std::string&gt; m;\n    m[1] = \"one\";\n    m[2] = \"two\";\n    m[3] = \"three\";\n\n    for (const auto&amp; [key, value] : m) {\n        std::cout &lt;&lt; key &lt;&lt; \": \" &lt;&lt; value &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"cpp/x/#3-unordered-containers","title":"3. Unordered Containers","text":"<p>Unordered containers use hash tables for fast access and do not maintain order. Introduced in C++11.</p>"},{"location":"cpp/x/#31-stdunordered_set-c11","title":"3.1 std::unordered_set (C++11)","text":"<p>A collection of unique elements with fast lookup.</p>"},{"location":"cpp/x/#32-stdunordered_map-c11","title":"3.2 std::unordered_map (C++11)","text":"<p>A hash table-based key-value container.</p> <p>Example:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n\nint main() {\n    std::unordered_map&lt;std::string, int&gt; um;\n    um[\"apple\"] = 3;\n    um[\"banana\"] = 5;\n    um[\"orange\"] = 7;\n\n    for (const auto&amp; [key, value] : um) {\n        std::cout &lt;&lt; key &lt;&lt; \": \" &lt;&lt; value &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre> <p>By understanding these features and their time complexities, you can select the right container for your application to maximize efficiency and performance.</p>"},{"location":"general/ros_package/","title":"ROS1 Package Creation Tutorial","text":"<p>Slide: http://luthuli.cs.uiuc.edu/~daf/courses/MAAV-2020/Slides/NewROSBlock.pdf</p>"},{"location":"general/ros_package/#overview","title":"Overview","text":"<p>Creating a ROS1 package allows you to structure your robot's software components in a modular way. A package can include nodes, libraries, launch files, and configuration files. This tutorial will guide you through the steps of creating a ROS1 package, setting up dependencies, and using tools like <code>vcstool</code> for version control of multiple repositories. We'll focus on C++ (roscpp) development as it provides better performance and type safety for robotic systems.</p>"},{"location":"general/ros_package/#procedure","title":"Procedure","text":""},{"location":"general/ros_package/#step-1-setup-your-ros-workspace","title":"Step 1: Setup Your ROS Workspace","text":"<p>Before creating a new package, make sure you have a ROS workspace. If you don't already have one, follow these steps:</p> <ol> <li> <p>Create a new workspace directory:</p> <p>``` mkdir -p ~/catkin_ws/src</p> <p>cd ~/catkin_ws/ ```</p> </li> <li> <p>Build the workspace:</p> <p><code>catkin_make</code></p> </li> <li> <p>Source the workspace setup file:</p> <p>`` source devel/setup.bash ```</p> </li> </ol>"},{"location":"general/ros_package/#step-2-create-a-new-package","title":"Step 2: Create a New Package","text":"<p>To create a new ROS package, navigate to the <code>src</code> directory of your workspace and run the following command:</p> <pre><code>cd ~/catkin_ws/src\ncatkin_create_pkg tutorial_02 std_msgs roscpp\n</code></pre> <p>This will create a package named <code>tutorial_02</code> with dependencies on <code>std_msgs</code> and <code>roscpp</code> (C++ ROS client library).</p>"},{"location":"general/ros_package/#step-3-explore-the-package-structure","title":"Step 3: Explore the Package Structure","text":"<p>After creating the package, take a moment to understand its structure:</p> <pre><code>cd tutorial_02\nls\n</code></pre> <p>You should see: - <code>CMakeLists.txt</code>: Build instructions for CMake - <code>package.xml</code>: Package metadata and dependencies - <code>include/tutorial_02/</code>: Headers directory for your C++ code - <code>src/</code>: Source directory for your C++ implementations</p>"},{"location":"general/ros_package/#step-4-build-the-package","title":"Step 4: Build the Package","text":"<p>Return to the root of your workspace and build it using catkin_make:</p> <pre><code>cd ~/catkin_ws\ncatkin_make\n</code></pre>"},{"location":"general/ros_package/#step-5-source-the-workspace-again","title":"Step 5: Source the Workspace Again","text":"<p>Source the workspace setup file to ensure that ROS recognizes the newly created package:</p> <pre><code>source devel/setup.bash\n</code></pre>"},{"location":"general/ros_package/#step-6-create-a-c-node","title":"Step 6: Create a C++ Node","text":"<p>Create a C++ source file in the src directory, for example <code>talker.cpp</code>:</p> <pre><code>touch ~/catkin_ws/src/tutorial_02/src/talker.cpp\n</code></pre> <p>Edit the <code>talker.cpp</code> file with your favorite editor and add the following code:</p> <pre><code>#include &lt;ros/ros.h&gt;\n#include &lt;std_msgs/String.h&gt;\n\nint main(int argc, char **argv)\n{\n  // Initialize ROS node\n  ros::init(argc, argv, \"talker\");\n\n  // Create a node handle\n  ros::NodeHandle n;\n\n  // Create a publisher object\n  ros::Publisher chatter_pub = n.advertise&lt;std_msgs::String&gt;(\"chatter\", 10);\n\n  // Set publishing rate (1 Hz)\n  ros::Rate loop_rate(1);\n\n  int count = 0;\n  while (ros::ok())\n  {\n    // Create message\n    std_msgs::String msg;\n    std::stringstream ss;\n    ss &lt;&lt; \"Hello, ROS! \" &lt;&lt; count;\n    msg.data = ss.str();\n\n    // Log and publish\n    ROS_INFO(\"%s\", msg.data.c_str());\n    chatter_pub.publish(msg);\n\n    // Process callbacks and sleep\n    ros::spinOnce();\n    loop_rate.sleep();\n    ++count;\n  }\n\n  return 0;\n}\n</code></pre>"},{"location":"general/ros_package/#step-7-update-cmakeliststxt","title":"Step 7: Update CMakeLists.txt","text":"<p>You need to update the CMakeLists.txt to build your new C++ node. Add the following to your CMakeLists.txt (around line 136, after the existing boilerplate):</p> <pre><code>add_executable(talker src/talker.cpp)\ntarget_link_libraries(talker ${catkin_LIBRARIES})\n</code></pre>"},{"location":"general/ros_package/#step-8-build-the-package-again","title":"Step 8: Build the Package Again","text":"<pre><code>cd ~/catkin_ws\ncatkin_make\n</code></pre>"},{"location":"general/ros_package/#step-9-create-a-launch-file-optional","title":"Step 9: Create a Launch File (Optional)","text":"<p>Create a launch file in the launch directory of your package to run your nodes:</p> <pre><code>mkdir -p ~/catkin_ws/src/tutorial_02/launch\n</code></pre> <p>Create the <code>talker.launch</code> file:</p> <pre><code>&lt;launch&gt;\n    &lt;node name=\"talker\" pkg=\"tutorial_02\" type=\"talker\" output=\"screen\" /&gt;\n&lt;/launch&gt;\n</code></pre> <p>Note that the type attribute doesn't have a file extension for C++ executables, unlike Python scripts.</p>"},{"location":"general/ros_package/#step-10-run-the-package","title":"Step 10: Run the Package","text":"<p>Now you can run the package using ROS tools like <code>rosrun</code> or <code>roslaunch</code>.</p> <p>To run the node directly:</p> <pre><code>rosrun tutorial_02 talker\n</code></pre> <p>Or, to launch the node using the launch file:</p> <pre><code>roslaunch tutorial_02 talker.launch\n</code></pre>"},{"location":"general/ros_package/#dependencies-management","title":"Dependencies Management","text":""},{"location":"general/ros_package/#understanding-ros-dependencies","title":"Understanding ROS Dependencies","text":"<p>ROS packages can have various types of dependencies, and they must be properly declared in both <code>package.xml</code> and <code>CMakeLists.txt</code>. Properly managing dependencies is crucial for ensuring your package builds correctly and can be distributed to others.</p>"},{"location":"general/ros_package/#checking-available-dependencies","title":"Checking Available Dependencies","text":"<p>Before adding dependencies to your package, you should check if they are available for your ROS distribution. The official repository of available ROS packages is maintained at:</p> <pre><code>https://github.com/ros/rosdistro\n</code></pre> <p>To find available packages for your specific ROS distribution (e.g., Noetic, Melodic), navigate to:</p> <pre><code>https://github.com/ros/rosdistro/blob/master/[DISTRO]/distribution.yaml\n</code></pre> <p>For system dependencies (non-ROS packages), you should also check:</p> <pre><code>https://github.com/ros/rosdistro/tree/master/rosdep/base.yaml\n</code></pre> <p>This file lists system dependencies that can be installed using <code>rosdep</code>, which helps manage both ROS and non-ROS dependencies.</p> <p>This file contains all officially available packages for your distribution, along with version information and repository URLs. Always check these resources before adding dependencies to ensure they are available for your ROS distribution.</p>"},{"location":"general/ros_package/#types-of-dependencies-in-packagexml","title":"Types of Dependencies in package.xml","text":"<p>In ROS package.xml, there are different types of dependency tags, each serving a specific purpose in the build process. Understanding these differences is crucial for beginners:</p> <ol> <li><code>&lt;build_depend&gt;</code>: These packages are required at build time</li> <li>Needed when compiling your package</li> <li>Example: header files, compile-time libraries</li> <li> <p>These dependencies are NOT exposed to packages depending on yours</p> </li> <li> <p><code>&lt;build_export_depend&gt;</code>: These packages are required for building packages that depend on yours</p> </li> <li>When other packages build against your package, they also need these dependencies</li> <li> <p>Example: header files that are included in your public headers</p> </li> <li> <p><code>&lt;exec_depend&gt;</code>: These packages are required at runtime</p> </li> <li>Needed when actually running your package</li> <li>Example: shared libraries, ROS message runtime packages</li> <li> <p>Required for users who just want to run your package without building it</p> </li> <li> <p><code>&lt;depend&gt;</code>: A convenience tag that combines all three dependency types</p> </li> <li>Equivalent to declaring <code>&lt;build_depend&gt;</code>, <code>&lt;build_export_depend&gt;</code>, and <code>&lt;exec_depend&gt;</code></li> <li>Use this when a package is needed for all three stages (common for most ROS dependencies)</li> </ol>"},{"location":"general/ros_package/#real-world-example","title":"Real-world Example","text":"<p>Let's use a practical example to understand these differences:</p> <pre><code>&lt;!-- For a C++ package that uses custom messages --&gt;\n&lt;!-- message_generation is only needed at build time --&gt;\n&lt;build_depend&gt;message_generation&lt;/build_depend&gt;\n\n&lt;!-- message_runtime is only needed at runtime --&gt;\n&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;\n\n&lt;!-- roscpp is needed at all stages --&gt;\n&lt;depend&gt;roscpp&lt;/depend&gt;\n\n&lt;!-- When using an external library --&gt;\n&lt;build_depend&gt;boost&lt;/build_depend&gt;       &lt;!-- If only used internally --&gt;\n&lt;depend&gt;opencv&lt;/depend&gt;                  &lt;!-- If used in public headers --&gt;\n</code></pre> <p>This distinction is particularly important for: - Custom message packages (message_generation vs message_runtime) - Large dependencies that shouldn't be propagated to dependents - Packages with different build and runtime components</p>"},{"location":"general/ros_package/#packagexml-dependencies","title":"Package.xml Dependencies","text":"<p>In your <code>package.xml</code>, dependencies are declared using these tags:</p> <pre><code>&lt;!-- For C++ packages --&gt;\n&lt;build_depend&gt;roscpp&lt;/build_depend&gt;\n&lt;build_export_depend&gt;roscpp&lt;/build_export_depend&gt;\n&lt;exec_depend&gt;roscpp&lt;/exec_depend&gt;\n\n&lt;!-- Other common dependencies --&gt;\n&lt;build_depend&gt;std_msgs&lt;/build_depend&gt;\n&lt;build_export_depend&gt;std_msgs&lt;/build_export_depend&gt;\n&lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;\n</code></pre> <p>For simplicity, when a package is needed at all stages, you can use the combined <code>&lt;depend&gt;</code> tag:</p> <pre><code>&lt;depend&gt;roscpp&lt;/depend&gt;\n&lt;depend&gt;std_msgs&lt;/depend&gt;\n</code></pre>"},{"location":"general/ros_package/#cmakeliststxt-dependencies","title":"CMakeLists.txt Dependencies","text":"<p>In <code>CMakeLists.txt</code>, dependencies are specified using <code>find_package</code>:</p> <pre><code>find_package(catkin REQUIRED COMPONENTS\n  roscpp\n  std_msgs\n)\n</code></pre> <p>It's important to ensure that all packages listed in <code>find_package</code> are also listed in your <code>package.xml</code> as either <code>&lt;build_depend&gt;</code> or <code>&lt;depend&gt;</code>.</p>"},{"location":"general/ros_package/#dependency-management-best-practices","title":"Dependency Management Best Practices","text":"<ol> <li>Minimize Dependencies: Only include packages you actually need</li> <li>Be Specific: Use the most specific dependency type for each package</li> <li>Version Management: For non-ROS dependencies, consider specifying version requirements:    <code>xml    &lt;build_depend version_gte=\"1.2.3\"&gt;some_package&lt;/build_depend&gt;</code></li> <li>Check Dependencies: Use <code>rosdep check</code> to verify all dependencies are installed:    <code>bash    rosdep check --from-paths src --ignore-src --rosdistro noetic</code></li> <li>Install Missing Dependencies: Use <code>rosdep</code> to install missing dependencies:    <code>bash    rosdep install --from-paths src --ignore-src --rosdistro noetic -y</code></li> </ol>"},{"location":"general/ros_package/#adding-custom-messages-services-or-actions","title":"Adding Custom Messages, Services, or Actions","text":"<p>If your package defines custom messages, services, or actions, you'll need additional configuration:</p> <ol> <li>Add message generation dependencies:</li> </ol> <pre><code>&lt;!-- In package.xml --&gt;\n&lt;build_depend&gt;message_generation&lt;/build_depend&gt;\n&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;\n</code></pre> <ol> <li>Update CMakeLists.txt:</li> </ol> <pre><code>find_package(catkin REQUIRED COMPONENTS\n  roscpp\n  std_msgs\n  message_generation\n)\n\n# Add message files\nadd_message_files(\n  FILES\n  MyCustomMsg.msg\n)\n\n# Generate messages\ngenerate_messages(\n  DEPENDENCIES\n  std_msgs\n)\n\n# Specify catkin package dependencies\ncatkin_package(\n  CATKIN_DEPENDS roscpp std_msgs message_runtime\n)\n</code></pre> <p>After adding the dependencies, remember to run:</p> <pre><code>cd ~/catkin_ws\ncatkin_make\nsource devel/setup.bash\n</code></pre>"},{"location":"general/ros_package/#troubleshooting-dependencies","title":"Troubleshooting Dependencies","text":"<p>Common dependency issues and solutions:</p> <ol> <li>Missing Dependency: If <code>catkin_make</code> fails with \"Could not find a package configuration file provided by [PACKAGE]\"</li> <li>Check if the package is installed: <code>apt-cache policy ros-[distro]-[package]</code></li> <li> <p>Install using rosdep: <code>rosdep install --from-paths src --ignore-src -y</code></p> </li> <li> <p>Incompatible Versions: If you get runtime errors about mismatched message definitions</p> </li> <li>Ensure all packages are from the same ROS distribution</li> <li> <p>Check for conflicting packages with <code>rospack profile</code></p> </li> <li> <p>Missing Libraries: If you get linker errors</p> </li> <li>Ensure the library is correctly listed in <code>target_link_libraries</code></li> <li>Check if library paths are correct with <code>catkin config --cmake-args -DCMAKE_VERBOSE_MAKEFILE=ON</code></li> </ol>"},{"location":"general/ros_package/#using-external-libraries","title":"Using External Libraries","text":"<p>To use external C++ libraries in your ROS package:</p> <ol> <li>Add the dependency in <code>package.xml</code>:</li> </ol> <pre><code>&lt;build_depend&gt;libname&lt;/build_depend&gt;\n&lt;exec_depend&gt;libname&lt;/exec_depend&gt;\n</code></pre> <ol> <li>Find and link the library in <code>CMakeLists.txt</code>:</li> </ol> <pre><code>find_package(LibName REQUIRED)\ninclude_directories(${LIBNAME_INCLUDE_DIRS})\ntarget_link_libraries(your_node ${catkin_LIBRARIES} ${LIBNAME_LIBRARIES})\n</code></pre> <ol> <li>For system libraries not found by CMake, you might need to use pkg-config:</li> </ol> <pre><code>find_package(PkgConfig REQUIRED)\npkg_check_modules(LIBNAME REQUIRED libname)\ninclude_directories(${LIBNAME_INCLUDE_DIRS})\nlink_directories(${LIBNAME_LIBRARY_DIRS})\nadd_definitions(${LIBNAME_CFLAGS})\ntarget_link_libraries(your_node ${catkin_LIBRARIES} ${LIBNAME_LIBRARIES})\n</code></pre>"},{"location":"general/ros_package/#managing-multiple-repositories-with-vcstool","title":"Managing Multiple Repositories with vcstool","text":"<p><code>vcstool</code> (Version Control System tool) allows you to manage multiple git repositories in your ROS workspace efficiently.</p>"},{"location":"general/ros_package/#step-1-install-vcstool","title":"Step 1: Install vcstool","text":"<p>First, install vcstool:</p> <pre><code>sudo apt-get install python3-vcstool\n</code></pre>"},{"location":"general/ros_package/#step-2-create-a-repos-file","title":"Step 2: Create a .repos File","text":"<p>Create a YAML file that specifies your repositories. For example, create <code>my_repos.repos</code>:</p> <pre><code>repositories:\n  src/tutorial_02:\n    type: git\n    url: https://github.com/username/tutorial_02.git\n    version: main\n  src/dependency_package:\n    type: git\n    url: https://github.com/username/dependency_package.git\n    version: main\n</code></pre>"},{"location":"general/ros_package/#step-3-import-repositories","title":"Step 3: Import Repositories","text":"<p>Use vcstool to clone all repositories:</p> <pre><code>vcs import ~/catkin_ws &lt; my_repos.repos\n</code></pre>"},{"location":"general/ros_package/#step-4-update-all-repositories","title":"Step 4: Update All Repositories","text":"<p>To update all repositories:</p> <pre><code>cd ~/catkin_ws\nvcs pull src\n</code></pre>"},{"location":"general/ros_package/#step-5-check-status-of-all-repositories","title":"Step 5: Check Status of All Repositories","text":"<p>To see the status of all repositories:</p> <pre><code>vcs status src\n</code></pre>"},{"location":"general/ros_package/#step-6-export-current-configuration","title":"Step 6: Export Current Configuration","text":"<p>To export your current repository configuration:</p> <pre><code>vcs export src &gt; current_repos.repos\n</code></pre>"},{"location":"general/ros_package/#creating-a-complete-c-ros-package","title":"Creating a Complete C++ ROS Package","text":"<p>Let's create a more complete example with a publisher and subscriber:</p> <ol> <li>Create a subscriber node in <code>src/listener.cpp</code>:</li> </ol> <pre><code>#include \"ros/ros.h\"\n#include \"std_msgs/String.h\"\n\n// Callback function\nvoid chatterCallback(const std_msgs::String::ConstPtr&amp; msg)\n{\n  ROS_INFO(\"I heard: [%s]\", msg-&gt;data.c_str());\n}\n\nint main(int argc, char **argv)\n{\n  // Initialize ROS node\n  ros::init(argc, argv, \"listener\");\n\n  // Create a node handle\n  ros::NodeHandle n;\n\n  // Subscribe to the \"chatter\" topic\n  ros::Subscriber sub = n.subscribe(\"chatter\", 10, chatterCallback);\n\n  // Process callbacks until node shutdown\n  ros::spin();\n\n  return 0;\n}\n</code></pre> <ol> <li>Update <code>CMakeLists.txt</code> to build the new node:</li> </ol> <pre><code>add_executable(listener src/listener.cpp)\ntarget_link_libraries(listener ${catkin_LIBRARIES})\n</code></pre> <ol> <li>Create a launch file to run both nodes:</li> </ol> <pre><code>&lt;launch&gt;\n  &lt;node name=\"talker\" pkg=\"tutorial_02\" type=\"talker\" output=\"screen\" /&gt;\n  &lt;node name=\"listener\" pkg=\"tutorial_02\" type=\"listener\" output=\"screen\" /&gt;\n&lt;/launch&gt;\n</code></pre> <ol> <li>Build and test your package:</li> </ol> <pre><code>cd ~/catkin_ws\ncatkin_make\nsource devel/setup.bash\nroslaunch tutorial_02 talker_listener.launch\n</code></pre>"},{"location":"general/ros_package/#best-practices-for-ros-c-packages","title":"Best Practices for ROS C++ Packages","text":"<ol> <li> <p>Use Header Files: Organize your code with header files in the <code>include/&lt;package_name&gt;/</code> directory.</p> </li> <li> <p>Follow Include Conventions: Use angle brackets for system-wide headers and quotes for project headers:    ```cpp    // For system and library headers (including ROS libraries)    #include     #include     #include     #include  <p>// For your own package headers    #include \"my_package/MyNode.h\"    #include \"my_package/utilities.h\"    ```    This convention makes it clear which headers are from external libraries and which are from your own project.</p> <ol> <li>Create Class-Based Nodes: Structure your nodes as classes for better organization:</li> </ol> <pre><code>// include/tutorial_02/MyNode.h\n#ifndef MY_NODE_H\n#define MY_NODE_H\n\n#include &lt;ros/ros.h&gt;\n#include &lt;std_msgs/String.h&gt;\n\nclass MyNode\n{\npublic:\n  MyNode();\n  void run();\n\nprivate:\n  ros::NodeHandle nh_;\n  ros::Publisher pub_;\n  ros::Timer timer_;\n  void timerCallback(const ros::TimerEvent&amp;);\n};\n\n#endif // MY_NODE_H\n</code></pre> <pre><code>// src/MyNode.cpp\n#include \"tutorial_02/MyNode.h\"\n\nMyNode::MyNode()\n{\n  pub_ = nh_.advertise&lt;std_msgs::String&gt;(\"chatter\", 10);\n  timer_ = nh_.createTimer(ros::Duration(1.0), &amp;MyNode::timerCallback, this);\n}\n\nvoid MyNode::timerCallback(const ros::TimerEvent&amp;)\n{\n  std_msgs::String msg;\n  msg.data = \"Hello from class-based node\";\n  pub_.publish(msg);\n  ROS_INFO(\"%s\", msg.data.c_str());\n}\n\nvoid MyNode::run()\n{\n  ros::spin();\n}\n\nint main(int argc, char **argv)\n{\n  ros::init(argc, argv, \"my_node\");\n  MyNode node;\n  node.run();\n  return 0;\n}\n</code></pre> <ol> <li>Use Parameter Server: Configure your nodes using ROS parameters:</li> </ol> <pre><code>std::string topic_name;\nnh_.param&lt;std::string&gt;(\"topic_name\", topic_name, \"default_topic\");\n</code></pre> <ol> <li> <p>Handle Errors Properly: Use try-catch blocks for error handling.</p> </li> <li> <p>Use ROS Logging: Utilize ROS_DEBUG, ROS_INFO, ROS_WARN, ROS_ERROR, and ROS_FATAL.</p> </li> <li> <p>Write Unit Tests: Use gtest with rostest for testing.</p> </li> </ol>"},{"location":"general/ros_package/#conclusion","title":"Conclusion","text":"<p>This tutorial has guided you through creating a ROS package with C++ (roscpp), managing dependencies, and using vcstool for repository management. By following these steps, you'll be able to create modular, maintainable, and efficient ROS packages for your robotics projects.</p>"},{"location":"general/vscode_ssh_github/","title":"VSCode Setup, SSH Key, and GitHub Basics for ROS Development","text":""},{"location":"general/vscode_ssh_github/#vscode","title":"VSCode","text":"<p>Visual Studio Code (VSCode) is a lightweight but powerful source code editor that supports multiple programming languages and extensions.</p>"},{"location":"general/vscode_ssh_github/#installation","title":"Installation","text":"<ol> <li>Download VSCode from the official website.</li> <li>Install it by following the on-screen instructions for your operating system.</li> </ol>"},{"location":"general/vscode_ssh_github/#essential-extensions-for-ros-development","title":"Essential Extensions for ROS Development","text":"<p>To enhance your ROS development experience, consider installing the following extensions: - ROS (Provides tools for working with ROS packages) - CMake Tools (For building ROS packages) - Python (Support for Python development in ROS) - C/C++ (Essential for C++ development in ROS) - Remote - SSH (For working with remote ROS robots) - GitHub Copilot (AI-powered coding assistant)</p>"},{"location":"general/vscode_ssh_github/#basic-usage","title":"Basic Usage","text":"<ul> <li>Open a ROS workspace: <code>File &gt; Open Folder</code></li> <li>Integrated Terminal: Open with <code>Ctrl + \\,</code></li> <li>Command Palette: Access with <code>Ctrl + Shift + P</code></li> <li>Version Control: View changes using the Source Control tab (<code>Ctrl + Shift + G</code>)</li> </ul>"},{"location":"general/vscode_ssh_github/#ssh-key","title":"SSH Key","text":"<p>SSH keys allow secure authentication with remote servers and Git repositories without using passwords.</p>"},{"location":"general/vscode_ssh_github/#generating-an-ssh-key","title":"Generating an SSH Key","text":"<ol> <li>Open a terminal and run:    <code>sh    ssh-keygen -t ed25519 -C \"your_email@example.com\"</code>    or just    <code>ssh-keygen</code></li> <li>Press Enter to accept the default location (<code>~/.ssh/id_ed25519</code>).</li> <li>Set a secure passphrase (optional but recommended).</li> </ol>"},{"location":"general/vscode_ssh_github/#adding-ssh-key-to-ssh-agent","title":"Adding SSH Key to SSH Agent","text":"<p>Start the SSH agent and add your key (should already by default):</p> <pre><code>ssh-agent bash\nssh-add ~/.ssh/id_ed25519\n</code></pre>"},{"location":"general/vscode_ssh_github/#putting-public-key-into-a-robot-for-ssh-without-password","title":"Putting Public key into a robot for SSH without Password","text":"<pre><code>cat ~/.ssh/id_ed25519.pub\n</code></pre> <p>Then copy this public key and paste to <code>~/.ssh/authorized_keys</code></p>"},{"location":"general/vscode_ssh_github/#adding-ssh-key-to-github","title":"Adding SSH Key to GitHub","text":"<ol> <li>Copy your public key:    <code>sh    cat ~/.ssh/id_ed25519.pub</code></li> <li>Go to GitHub SSH Keys Settings.</li> <li>Click New SSH Key, paste your key, and save it.</li> <li>Test the connection:    <code>sh    ssh -T git@github.com</code>    You should see a success message.</li> </ol>"},{"location":"general/vscode_ssh_github/#github-basics","title":"GitHub Basics","text":"<p>GitHub is a platform for version control and collaboration using Git.</p>"},{"location":"general/vscode_ssh_github/#configuring-git","title":"Configuring Git","text":"<p>Set up your user information:</p> <pre><code>git config user.name \"Your Name\"\ngit config user.email \"your_email@example.com\"\n</code></pre>"},{"location":"general/vscode_ssh_github/#cloning-a-ros-repository","title":"Cloning a ROS Repository","text":"<p>To clone a ROS package repository using SSH:</p> <pre><code>git clone git@github.com:your-username/ros-package.git\n</code></pre>"},{"location":"general/vscode_ssh_github/#basic-git-commands","title":"Basic Git Commands","text":"<ul> <li>Check Status:   <code>sh   git status</code></li> <li>Add Files to Staging:   <code>sh   git add .</code></li> <li>Commit Changes:   <code>sh   git commit -m \"Your commit message\"</code></li> <li>Push Changes:   <code>sh   git push origin main</code></li> <li>Pull Latest Changes:   <code>sh   git pull origin main</code></li> <li>Stash (Store change to local only, not in timeline):   <code>sh   git stash</code>   or   <code>sh   git stash save \"Your message here\"</code></li> <li>List Stashes <code>sh   git stash list</code></li> <li>Pop Stash (Apply and remove stash)   <code>sh   git stash pop stash@{N} # Replace N with stash index</code></li> <li>Rebase (Stash local change, pull, apply local change):   <code>sh   git pull --rebase</code></li> </ul>"},{"location":"general/vscode_ssh_github/#ros-specific-git-practices","title":"ROS-Specific Git Practices","text":"<ul> <li>Use branching for feature development (<code>git checkout -b feature-branch</code>).</li> <li>Follow ROS package naming conventions.</li> <li>Tag releases for stable versions (<code>git tag -a v1.0 -m \"Release version 1.0\"</code>).</li> <li>Utilize GitHub issues and pull requests for collaborative ROS development.</li> </ul> <p>This guide covers the basics to get started with VSCode, SSH keys, and GitHub for ROS development. Happy coding!</p>"}]}